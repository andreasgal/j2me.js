{"version":3,"file":"browserfs.min.js","sources":["../../vendor/almond/almond.js","core/api_error.js","core/buffer_core.js","core/buffer_core_imagedata.js","core/buffer_core_array.js","core/buffer_core_arraybuffer.js","core/string_util.js","core/buffer.js","core/node_eventemitter.js","core/file_flag.js","core/node_process.js","core/node_path.js","core/node_fs.js","generic/emscripten_fs.js","core/browserfs.js","core/file_system.js","generic/inode.js","core/node_fs_stats.js","core/file.js","generic/preload_file.js","generic/key_value_filesystem.js","core/global.js","backend/IndexedDB.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                name = baseParts.concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"../../vendor/almond/almond\", function(){});\n\n","/**\n* @module core/api_error\n*/\ndefine('core/api_error',[\"require\", \"exports\"], function(require, exports) {\n    /**\n    * Standard libc error codes. Add more to this enum and ErrorStrings as they are\n    * needed.\n    * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\n    */\n    (function (ErrorCode) {\n        ErrorCode[ErrorCode[\"EPERM\"] = 0] = \"EPERM\";\n        ErrorCode[ErrorCode[\"ENOENT\"] = 1] = \"ENOENT\";\n        ErrorCode[ErrorCode[\"EIO\"] = 2] = \"EIO\";\n        ErrorCode[ErrorCode[\"EBADF\"] = 3] = \"EBADF\";\n        ErrorCode[ErrorCode[\"EACCES\"] = 4] = \"EACCES\";\n        ErrorCode[ErrorCode[\"EBUSY\"] = 5] = \"EBUSY\";\n        ErrorCode[ErrorCode[\"EEXIST\"] = 6] = \"EEXIST\";\n        ErrorCode[ErrorCode[\"ENOTDIR\"] = 7] = \"ENOTDIR\";\n        ErrorCode[ErrorCode[\"EISDIR\"] = 8] = \"EISDIR\";\n        ErrorCode[ErrorCode[\"EINVAL\"] = 9] = \"EINVAL\";\n        ErrorCode[ErrorCode[\"EFBIG\"] = 10] = \"EFBIG\";\n        ErrorCode[ErrorCode[\"ENOSPC\"] = 11] = \"ENOSPC\";\n        ErrorCode[ErrorCode[\"EROFS\"] = 12] = \"EROFS\";\n        ErrorCode[ErrorCode[\"ENOTEMPTY\"] = 13] = \"ENOTEMPTY\";\n        ErrorCode[ErrorCode[\"ENOTSUP\"] = 14] = \"ENOTSUP\";\n    })(exports.ErrorCode || (exports.ErrorCode = {}));\n    var ErrorCode = exports.ErrorCode;\n\n    /**\n    * Strings associated with each error code.\n    */\n    var ErrorStrings = {};\n    ErrorStrings[0 /* EPERM */] = 'Operation not permitted.';\n    ErrorStrings[1 /* ENOENT */] = 'No such file or directory.';\n    ErrorStrings[2 /* EIO */] = 'Input/output error.';\n    ErrorStrings[3 /* EBADF */] = 'Bad file descriptor.';\n    ErrorStrings[4 /* EACCES */] = 'Permission denied.';\n    ErrorStrings[5 /* EBUSY */] = 'Resource busy or locked.';\n    ErrorStrings[6 /* EEXIST */] = 'File exists.';\n    ErrorStrings[7 /* ENOTDIR */] = 'File is not a directory.';\n    ErrorStrings[8 /* EISDIR */] = 'File is a directory.';\n    ErrorStrings[9 /* EINVAL */] = 'Invalid argument.';\n    ErrorStrings[10 /* EFBIG */] = 'File is too big.';\n    ErrorStrings[11 /* ENOSPC */] = 'No space left on disk.';\n    ErrorStrings[12 /* EROFS */] = 'Cannot modify a read-only file system.';\n    ErrorStrings[13 /* ENOTEMPTY */] = 'Directory is not empty.';\n    ErrorStrings[14 /* ENOTSUP */] = 'Operation is not supported.';\n\n    /**\n    * Represents a BrowserFS error. Passed back to applications after a failed\n    * call to the BrowserFS API.\n    */\n    var ApiError = (function () {\n        /**\n        * Represents a BrowserFS error. Passed back to applications after a failed\n        * call to the BrowserFS API.\n        *\n        * Error codes mirror those returned by regular Unix file operations, which is\n        * what Node returns.\n        * @constructor ApiError\n        * @param type The type of the error.\n        * @param [message] A descriptive error message.\n        */\n        function ApiError(type, message) {\n            this.type = type;\n            this.code = ErrorCode[type];\n            if (message != null) {\n                this.message = message;\n            } else {\n                this.message = ErrorStrings[type];\n            }\n        }\n        /**\n        * @return A friendly error message.\n        */\n        ApiError.prototype.toString = function () {\n            return this.code + \": \" + ErrorStrings[this.type] + \" \" + this.message;\n        };\n\n        ApiError.FileError = function (code, p) {\n            return new ApiError(code, p + \": \" + ErrorStrings[code]);\n        };\n        ApiError.ENOENT = function (path) {\n            return this.FileError(1 /* ENOENT */, path);\n        };\n\n        ApiError.EEXIST = function (path) {\n            return this.FileError(6 /* EEXIST */, path);\n        };\n\n        ApiError.EISDIR = function (path) {\n            return this.FileError(8 /* EISDIR */, path);\n        };\n\n        ApiError.ENOTDIR = function (path) {\n            return this.FileError(7 /* ENOTDIR */, path);\n        };\n\n        ApiError.EPERM = function (path) {\n            return this.FileError(0 /* EPERM */, path);\n        };\n        return ApiError;\n    })();\n    exports.ApiError = ApiError;\n});\n//# sourceMappingURL=api_error.js.map\n;\n","define('core/buffer_core',[\"require\", \"exports\", './api_error'], function(require, exports, api_error) {\n    var FLOAT_POS_INFINITY = Math.pow(2, 128);\n    var FLOAT_NEG_INFINITY = -1 * FLOAT_POS_INFINITY;\n    var FLOAT_POS_INFINITY_AS_INT = 0x7F800000;\n    var FLOAT_NEG_INFINITY_AS_INT = -8388608;\n    var FLOAT_NaN_AS_INT = 0x7fc00000;\n\n    \n\n    /**\n    * Contains common definitions for most of the BufferCore classes.\n    * Subclasses only need to implement write/readUInt8 for full functionality.\n    */\n    var BufferCoreCommon = (function () {\n        function BufferCoreCommon() {\n        }\n        BufferCoreCommon.prototype.getLength = function () {\n            throw new api_error.ApiError(14 /* ENOTSUP */, 'BufferCore implementations should implement getLength.');\n        };\n        BufferCoreCommon.prototype.writeInt8 = function (i, data) {\n            // Pack the sign bit as the highest bit.\n            // Note that we keep the highest bit in the value byte as the sign bit if it\n            // exists.\n            this.writeUInt8(i, (data & 0xFF) | ((data & 0x80000000) >>> 24));\n        };\n        BufferCoreCommon.prototype.writeInt16LE = function (i, data) {\n            this.writeUInt8(i, data & 0xFF);\n\n            // Pack the sign bit as the highest bit.\n            // Note that we keep the highest bit in the value byte as the sign bit if it\n            // exists.\n            this.writeUInt8(i + 1, ((data >>> 8) & 0xFF) | ((data & 0x80000000) >>> 24));\n        };\n        BufferCoreCommon.prototype.writeInt16BE = function (i, data) {\n            this.writeUInt8(i + 1, data & 0xFF);\n\n            // Pack the sign bit as the highest bit.\n            // Note that we keep the highest bit in the value byte as the sign bit if it\n            // exists.\n            this.writeUInt8(i, ((data >>> 8) & 0xFF) | ((data & 0x80000000) >>> 24));\n        };\n        BufferCoreCommon.prototype.writeInt32LE = function (i, data) {\n            this.writeUInt8(i, data & 0xFF);\n            this.writeUInt8(i + 1, (data >>> 8) & 0xFF);\n            this.writeUInt8(i + 2, (data >>> 16) & 0xFF);\n            this.writeUInt8(i + 3, (data >>> 24) & 0xFF);\n        };\n        BufferCoreCommon.prototype.writeInt32BE = function (i, data) {\n            this.writeUInt8(i + 3, data & 0xFF);\n            this.writeUInt8(i + 2, (data >>> 8) & 0xFF);\n            this.writeUInt8(i + 1, (data >>> 16) & 0xFF);\n            this.writeUInt8(i, (data >>> 24) & 0xFF);\n        };\n        BufferCoreCommon.prototype.writeUInt8 = function (i, data) {\n            throw new api_error.ApiError(14 /* ENOTSUP */, 'BufferCore implementations should implement writeUInt8.');\n        };\n        BufferCoreCommon.prototype.writeUInt16LE = function (i, data) {\n            this.writeUInt8(i, data & 0xFF);\n            this.writeUInt8(i + 1, (data >> 8) & 0xFF);\n        };\n        BufferCoreCommon.prototype.writeUInt16BE = function (i, data) {\n            this.writeUInt8(i + 1, data & 0xFF);\n            this.writeUInt8(i, (data >> 8) & 0xFF);\n        };\n        BufferCoreCommon.prototype.writeUInt32LE = function (i, data) {\n            this.writeInt32LE(i, data | 0);\n        };\n        BufferCoreCommon.prototype.writeUInt32BE = function (i, data) {\n            this.writeInt32BE(i, data | 0);\n        };\n        BufferCoreCommon.prototype.writeFloatLE = function (i, data) {\n            this.writeInt32LE(i, this.float2intbits(data));\n        };\n        BufferCoreCommon.prototype.writeFloatBE = function (i, data) {\n            this.writeInt32BE(i, this.float2intbits(data));\n        };\n        BufferCoreCommon.prototype.writeDoubleLE = function (i, data) {\n            var doubleBits = this.double2longbits(data);\n            this.writeInt32LE(i, doubleBits[0]);\n            this.writeInt32LE(i + 4, doubleBits[1]);\n        };\n        BufferCoreCommon.prototype.writeDoubleBE = function (i, data) {\n            var doubleBits = this.double2longbits(data);\n            this.writeInt32BE(i + 4, doubleBits[0]);\n            this.writeInt32BE(i, doubleBits[1]);\n        };\n        BufferCoreCommon.prototype.readInt8 = function (i) {\n            var val = this.readUInt8(i);\n            if (val & 0x80) {\n                // Sign bit is set, so perform sign extension.\n                return val | 0xFFFFFF80;\n            } else {\n                return val;\n            }\n        };\n        BufferCoreCommon.prototype.readInt16LE = function (i) {\n            var val = this.readUInt16LE(i);\n            if (val & 0x8000) {\n                // Sign bit is set, so perform sign extension.\n                return val | 0xFFFF8000;\n            } else {\n                return val;\n            }\n        };\n        BufferCoreCommon.prototype.readInt16BE = function (i) {\n            var val = this.readUInt16BE(i);\n            if (val & 0x8000) {\n                // Sign bit is set, so perform sign extension.\n                return val | 0xFFFF8000;\n            } else {\n                return val;\n            }\n        };\n        BufferCoreCommon.prototype.readInt32LE = function (i) {\n            return this.readUInt32LE(i) | 0;\n        };\n        BufferCoreCommon.prototype.readInt32BE = function (i) {\n            return this.readUInt32BE(i) | 0;\n        };\n        BufferCoreCommon.prototype.readUInt8 = function (i) {\n            throw new api_error.ApiError(14 /* ENOTSUP */, 'BufferCore implementations should implement readUInt8.');\n        };\n        BufferCoreCommon.prototype.readUInt16LE = function (i) {\n            return (this.readUInt8(i + 1) << 8) | this.readUInt8(i);\n        };\n        BufferCoreCommon.prototype.readUInt16BE = function (i) {\n            return (this.readUInt8(i) << 8) | this.readUInt8(i + 1);\n        };\n        BufferCoreCommon.prototype.readUInt32LE = function (i) {\n            return ((this.readUInt8(i + 3) << 24) | (this.readUInt8(i + 2) << 16) | (this.readUInt8(i + 1) << 8) | this.readUInt8(i)) >>> 0;\n        };\n        BufferCoreCommon.prototype.readUInt32BE = function (i) {\n            return ((this.readUInt8(i) << 24) | (this.readUInt8(i + 1) << 16) | (this.readUInt8(i + 2) << 8) | this.readUInt8(i + 3)) >>> 0;\n        };\n        BufferCoreCommon.prototype.readFloatLE = function (i) {\n            return this.intbits2float(this.readInt32LE(i));\n        };\n        BufferCoreCommon.prototype.readFloatBE = function (i) {\n            return this.intbits2float(this.readInt32BE(i));\n        };\n        BufferCoreCommon.prototype.readDoubleLE = function (i) {\n            return this.longbits2double(this.readInt32LE(i + 4), this.readInt32LE(i));\n        };\n        BufferCoreCommon.prototype.readDoubleBE = function (i) {\n            return this.longbits2double(this.readInt32BE(i), this.readInt32BE(i + 4));\n        };\n        BufferCoreCommon.prototype.copy = function (start, end) {\n            throw new api_error.ApiError(14 /* ENOTSUP */, 'BufferCore implementations should implement copy.');\n        };\n        BufferCoreCommon.prototype.fill = function (value, start, end) {\n            for (var i = start; i < end; i++) {\n                this.writeUInt8(i, value);\n            }\n        };\n\n        BufferCoreCommon.prototype.float2intbits = function (f_val) {\n            var exp, f_view, i_view, sig, sign;\n\n            // Special cases!\n            if (f_val === 0) {\n                return 0;\n            }\n\n            // We map the infinities to JavaScript infinities. Map them back.\n            if (f_val === Number.POSITIVE_INFINITY) {\n                return FLOAT_POS_INFINITY_AS_INT;\n            }\n            if (f_val === Number.NEGATIVE_INFINITY) {\n                return FLOAT_NEG_INFINITY_AS_INT;\n            }\n\n            // Convert JavaScript NaN to Float NaN value.\n            if (isNaN(f_val)) {\n                return FLOAT_NaN_AS_INT;\n            }\n\n            // We have more bits of precision than a float, so below we round to\n            // the nearest significand. This appears to be what the x86\n            // Java does for normal floating point operations.\n            sign = f_val < 0 ? 1 : 0;\n            f_val = Math.abs(f_val);\n\n            // Subnormal zone!\n            // (−1)^signbits×2^−126×0.significandbits\n            // Largest subnormal magnitude:\n            // 0000 0000 0111 1111 1111 1111 1111 1111\n            // Smallest subnormal magnitude:\n            // 0000 0000 0000 0000 0000 0000 0000 0001\n            if (f_val <= 1.1754942106924411e-38 && f_val >= 1.4012984643248170e-45) {\n                exp = 0;\n                sig = Math.round((f_val / Math.pow(2, -126)) * Math.pow(2, 23));\n                return (sign << 31) | (exp << 23) | sig;\n            } else {\n                // Regular FP numbers\n                exp = Math.floor(Math.log(f_val) / Math.LN2);\n                sig = Math.round((f_val / Math.pow(2, exp) - 1) * Math.pow(2, 23));\n                return (sign << 31) | ((exp + 127) << 23) | sig;\n            }\n        };\n\n        BufferCoreCommon.prototype.double2longbits = function (d_val) {\n            var d_view, exp, high_bits, i_view, sig, sign;\n\n            // Special cases\n            if (d_val === 0) {\n                return [0, 0];\n            }\n            if (d_val === Number.POSITIVE_INFINITY) {\n                // High bits: 0111 1111 1111 0000 0000 0000 0000 0000\n                //  Low bits: 0000 0000 0000 0000 0000 0000 0000 0000\n                return [0, 2146435072];\n            } else if (d_val === Number.NEGATIVE_INFINITY) {\n                // High bits: 1111 1111 1111 0000 0000 0000 0000 0000\n                //  Low bits: 0000 0000 0000 0000 0000 0000 0000 0000\n                return [0, -1048576];\n            } else if (isNaN(d_val)) {\n                // High bits: 0111 1111 1111 1000 0000 0000 0000 0000\n                //  Low bits: 0000 0000 0000 0000 0000 0000 0000 0000\n                return [0, 2146959360];\n            }\n            sign = d_val < 0 ? 1 << 31 : 0;\n            d_val = Math.abs(d_val);\n\n            // Check if it is a subnormal number.\n            // (-1)s × 0.f × 2-1022\n            // Largest subnormal magnitude:\n            // 0000 0000 0000 1111 1111 1111 1111 1111\n            // 1111 1111 1111 1111 1111 1111 1111 1111\n            // Smallest subnormal magnitude:\n            // 0000 0000 0000 0000 0000 0000 0000 0000\n            // 0000 0000 0000 0000 0000 0000 0000 0001\n            if (d_val <= 2.2250738585072010e-308 && d_val >= 5.0000000000000000e-324) {\n                exp = 0;\n                sig = (d_val / Math.pow(2, -1022)) * Math.pow(2, 52);\n            } else {\n                exp = Math.floor(Math.log(d_val) / Math.LN2);\n\n                // If d_val is close to a power of two, there's a chance that exp\n                // will be 1 greater than it should due to loss of accuracy in the\n                // log result.\n                if (d_val < Math.pow(2, exp)) {\n                    exp = exp - 1;\n                }\n                sig = (d_val / Math.pow(2, exp) - 1) * Math.pow(2, 52);\n                exp = (exp + 1023) << 20;\n            }\n\n            // Simulate >> 32\n            high_bits = ((sig * Math.pow(2, -32)) | 0) | sign | exp;\n            return [sig & 0xFFFF, high_bits];\n        };\n\n        BufferCoreCommon.prototype.intbits2float = function (int32) {\n            // Map +/- infinity to JavaScript equivalents\n            if (int32 === FLOAT_POS_INFINITY_AS_INT) {\n                return Number.POSITIVE_INFINITY;\n            } else if (int32 === FLOAT_NEG_INFINITY_AS_INT) {\n                return Number.NEGATIVE_INFINITY;\n            }\n            var sign = (int32 & 0x80000000) >>> 31;\n            var exponent = (int32 & 0x7F800000) >>> 23;\n            var significand = int32 & 0x007FFFFF;\n            var value;\n            if (exponent === 0) {\n                value = Math.pow(-1, sign) * significand * Math.pow(2, -149);\n            } else {\n                value = Math.pow(-1, sign) * (1 + significand * Math.pow(2, -23)) * Math.pow(2, exponent - 127);\n            }\n\n            // NaN check\n            if (value < FLOAT_NEG_INFINITY || value > FLOAT_POS_INFINITY) {\n                value = NaN;\n            }\n            return value;\n        };\n\n        BufferCoreCommon.prototype.longbits2double = function (uint32_a, uint32_b) {\n            var sign = (uint32_a & 0x80000000) >>> 31;\n            var exponent = (uint32_a & 0x7FF00000) >>> 20;\n            var significand = ((uint32_a & 0x000FFFFF) * Math.pow(2, 32)) + uint32_b;\n\n            // Special values!\n            if (exponent === 0 && significand === 0) {\n                return 0;\n            }\n            if (exponent === 2047) {\n                if (significand === 0) {\n                    if (sign === 1) {\n                        return Number.NEGATIVE_INFINITY;\n                    }\n                    return Number.POSITIVE_INFINITY;\n                } else {\n                    return NaN;\n                }\n            }\n            if (exponent === 0)\n                return Math.pow(-1, sign) * significand * Math.pow(2, -1074);\n            return Math.pow(-1, sign) * (1 + significand * Math.pow(2, -52)) * Math.pow(2, exponent - 1023);\n        };\n        return BufferCoreCommon;\n    })();\n    exports.BufferCoreCommon = BufferCoreCommon;\n});\n//# sourceMappingURL=buffer_core.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/buffer_core_imagedata',[\"require\", \"exports\", './buffer_core'], function(require, exports, buffer_core) {\n    \n\n    /**\n    * Implementation of BufferCore that is backed by an ImageData object.\n    * Useful in browsers with HTML5 canvas support, but no TypedArray support\n    * (IE9).\n    */\n    var BufferCoreImageData = (function (_super) {\n        __extends(BufferCoreImageData, _super);\n        function BufferCoreImageData(length) {\n            _super.call(this);\n            this.length = length;\n            this.buff = BufferCoreImageData.getCanvasPixelArray(length);\n        }\n        /**\n        * Constructs a CanvasPixelArray that represents the given amount of bytes.\n        */\n        BufferCoreImageData.getCanvasPixelArray = function (bytes) {\n            var ctx = BufferCoreImageData.imageDataFactory;\n\n            // Lazily initialize, otherwise every browser (even those that will never\n            // use this code) will create a canvas on script load.\n            if (ctx === undefined) {\n                BufferCoreImageData.imageDataFactory = ctx = document.createElement('canvas').getContext('2d');\n            }\n\n            // You cannot create image data with size 0, so up it to size 1.\n            if (bytes === 0)\n                bytes = 1;\n            return ctx.createImageData(Math.ceil(bytes / 4), 1).data;\n        };\n        BufferCoreImageData.isAvailable = function () {\n            // Modern browsers have removed this deprecated API, so it is not always around.\n            return typeof CanvasPixelArray !== 'undefined';\n        };\n\n        BufferCoreImageData.prototype.getLength = function () {\n            return this.length;\n        };\n        BufferCoreImageData.prototype.writeUInt8 = function (i, data) {\n            this.buff[i] = data;\n        };\n        BufferCoreImageData.prototype.readUInt8 = function (i) {\n            return this.buff[i];\n        };\n        BufferCoreImageData.prototype.copy = function (start, end) {\n            // AFAIK, there's no efficient way to clone ImageData.\n            var newBC = new BufferCoreImageData(end - start);\n            for (var i = start; i < end; i++) {\n                newBC.writeUInt8(i - start, this.buff[i]);\n            }\n            return newBC;\n        };\n        return BufferCoreImageData;\n    })(buffer_core.BufferCoreCommon);\n    exports.BufferCoreImageData = BufferCoreImageData;\n\n    // Type-check the class.\n    var _ = BufferCoreImageData;\n});\n//# sourceMappingURL=buffer_core_imagedata.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/buffer_core_array',[\"require\", \"exports\", './buffer_core'], function(require, exports, buffer_core) {\n    // Used to clear segments of an array index.\n    var clearMasks = [0xFFFFFF00, 0xFFFF00FF, 0xFF00FFFF, 0x00FFFFFF];\n\n    /**\n    * Implementation of BufferCore that is backed by an array of 32-bit ints.\n    * Data is stored little endian.\n    * Example: Bytes 0 through 3 are present in the first int:\n    *  BYTE 3      BYTE 2      BYTE 1      BYTE 0\n    * 0000 0000 | 0000 0000 | 0000 0000 | 0000 0000\n    */\n    var BufferCoreArray = (function (_super) {\n        __extends(BufferCoreArray, _super);\n        function BufferCoreArray(length) {\n            _super.call(this);\n            this.length = length;\n            this.buff = new Array(Math.ceil(length / 4));\n\n            // Zero-fill the array.\n            var bufflen = this.buff.length;\n            for (var i = 0; i < bufflen; i++) {\n                this.buff[i] = 0;\n            }\n        }\n        BufferCoreArray.isAvailable = function () {\n            return true;\n        };\n\n        BufferCoreArray.prototype.getLength = function () {\n            return this.length;\n        };\n        BufferCoreArray.prototype.writeUInt8 = function (i, data) {\n            data &= 0xFF;\n\n            // Which int? (Equivalent to (i/4)|0)\n            var arrIdx = i >> 2;\n\n            // Which offset? (Equivalent to i - arrIdx*4)\n            var intIdx = i & 3;\n            this.buff[arrIdx] = this.buff[arrIdx] & clearMasks[intIdx];\n            this.buff[arrIdx] = this.buff[arrIdx] | (data << (intIdx << 3));\n        };\n        BufferCoreArray.prototype.readUInt8 = function (i) {\n            // Which int?\n            var arrIdx = i >> 2;\n\n            // Which offset?\n            var intIdx = i & 3;\n\n            // Bring the data we want into the lowest 8 bits, and truncate.\n            return (this.buff[arrIdx] >> (intIdx << 3)) & 0xFF;\n        };\n        BufferCoreArray.prototype.copy = function (start, end) {\n            // Stupid unoptimized copy. Later, we could do optimizations when aligned.\n            var newBC = new BufferCoreArray(end - start);\n            for (var i = start; i < end; i++) {\n                newBC.writeUInt8(i - start, this.readUInt8(i));\n            }\n            return newBC;\n        };\n        return BufferCoreArray;\n    })(buffer_core.BufferCoreCommon);\n    exports.BufferCoreArray = BufferCoreArray;\n\n    // Type-check the class.\n    var _ = BufferCoreArray;\n});\n//# sourceMappingURL=buffer_core_array.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/buffer_core_arraybuffer',[\"require\", \"exports\", './buffer_core'], function(require, exports, buffer_core) {\n    /**\n    * Represents data using an ArrayBuffer.\n    */\n    var BufferCoreArrayBuffer = (function (_super) {\n        __extends(BufferCoreArrayBuffer, _super);\n        function BufferCoreArrayBuffer(arg1) {\n            _super.call(this);\n            if (typeof arg1 === 'number') {\n                this.buff = new DataView(new ArrayBuffer(arg1));\n            } else if (arg1 instanceof DataView) {\n                this.buff = arg1;\n            } else {\n                this.buff = new DataView(arg1);\n            }\n            this.length = this.buff.byteLength;\n        }\n        BufferCoreArrayBuffer.isAvailable = function () {\n            return typeof DataView !== 'undefined';\n        };\n\n        BufferCoreArrayBuffer.prototype.getLength = function () {\n            return this.length;\n        };\n        BufferCoreArrayBuffer.prototype.writeInt8 = function (i, data) {\n            this.buff.setInt8(i, data);\n        };\n        BufferCoreArrayBuffer.prototype.writeInt16LE = function (i, data) {\n            this.buff.setInt16(i, data, true);\n        };\n        BufferCoreArrayBuffer.prototype.writeInt16BE = function (i, data) {\n            this.buff.setInt16(i, data, false);\n        };\n        BufferCoreArrayBuffer.prototype.writeInt32LE = function (i, data) {\n            this.buff.setInt32(i, data, true);\n        };\n        BufferCoreArrayBuffer.prototype.writeInt32BE = function (i, data) {\n            this.buff.setInt32(i, data, false);\n        };\n        BufferCoreArrayBuffer.prototype.writeUInt8 = function (i, data) {\n            this.buff.setUint8(i, data);\n        };\n        BufferCoreArrayBuffer.prototype.writeUInt16LE = function (i, data) {\n            this.buff.setUint16(i, data, true);\n        };\n        BufferCoreArrayBuffer.prototype.writeUInt16BE = function (i, data) {\n            this.buff.setUint16(i, data, false);\n        };\n        BufferCoreArrayBuffer.prototype.writeUInt32LE = function (i, data) {\n            this.buff.setUint32(i, data, true);\n        };\n        BufferCoreArrayBuffer.prototype.writeUInt32BE = function (i, data) {\n            this.buff.setUint32(i, data, false);\n        };\n        BufferCoreArrayBuffer.prototype.writeFloatLE = function (i, data) {\n            this.buff.setFloat32(i, data, true);\n        };\n        BufferCoreArrayBuffer.prototype.writeFloatBE = function (i, data) {\n            this.buff.setFloat32(i, data, false);\n        };\n        BufferCoreArrayBuffer.prototype.writeDoubleLE = function (i, data) {\n            this.buff.setFloat64(i, data, true);\n        };\n        BufferCoreArrayBuffer.prototype.writeDoubleBE = function (i, data) {\n            this.buff.setFloat64(i, data, false);\n        };\n        BufferCoreArrayBuffer.prototype.readInt8 = function (i) {\n            return this.buff.getInt8(i);\n        };\n        BufferCoreArrayBuffer.prototype.readInt16LE = function (i) {\n            return this.buff.getInt16(i, true);\n        };\n        BufferCoreArrayBuffer.prototype.readInt16BE = function (i) {\n            return this.buff.getInt16(i, false);\n        };\n        BufferCoreArrayBuffer.prototype.readInt32LE = function (i) {\n            return this.buff.getInt32(i, true);\n        };\n        BufferCoreArrayBuffer.prototype.readInt32BE = function (i) {\n            return this.buff.getInt32(i, false);\n        };\n        BufferCoreArrayBuffer.prototype.readUInt8 = function (i) {\n            return this.buff.getUint8(i);\n        };\n        BufferCoreArrayBuffer.prototype.readUInt16LE = function (i) {\n            return this.buff.getUint16(i, true);\n        };\n        BufferCoreArrayBuffer.prototype.readUInt16BE = function (i) {\n            return this.buff.getUint16(i, false);\n        };\n        BufferCoreArrayBuffer.prototype.readUInt32LE = function (i) {\n            return this.buff.getUint32(i, true);\n        };\n        BufferCoreArrayBuffer.prototype.readUInt32BE = function (i) {\n            return this.buff.getUint32(i, false);\n        };\n        BufferCoreArrayBuffer.prototype.readFloatLE = function (i) {\n            return this.buff.getFloat32(i, true);\n        };\n        BufferCoreArrayBuffer.prototype.readFloatBE = function (i) {\n            return this.buff.getFloat32(i, false);\n        };\n        BufferCoreArrayBuffer.prototype.readDoubleLE = function (i) {\n            return this.buff.getFloat64(i, true);\n        };\n        BufferCoreArrayBuffer.prototype.readDoubleBE = function (i) {\n            return this.buff.getFloat64(i, false);\n        };\n        BufferCoreArrayBuffer.prototype.copy = function (start, end) {\n            var aBuff = this.buff.buffer;\n            var newBuff;\n\n            // Some ArrayBuffer implementations (IE10) do not have 'slice'.\n            // XXX: Type hacks - the typings don't have slice either.\n            if (ArrayBuffer.prototype.slice) {\n                // ArrayBuffer.slice is copying; exactly what we want.\n                newBuff = aBuff.slice(start, end);\n            } else {\n                var len = end - start;\n                newBuff = new ArrayBuffer(len);\n\n                // Copy the old contents in.\n                var newUintArray = new Uint8Array(newBuff);\n                var oldUintArray = new Uint8Array(aBuff);\n                newUintArray.set(oldUintArray.subarray(start, end));\n            }\n            return new BufferCoreArrayBuffer(newBuff);\n        };\n        BufferCoreArrayBuffer.prototype.fill = function (value, start, end) {\n            // Value must be a byte wide.\n            value = value & 0xFF;\n            var i;\n            var len = end - start;\n            var intBytes = (((len) / 4) | 0) * 4;\n\n            // Optimization: Write 4 bytes at a time.\n            // TODO: Could we copy 8 bytes at a time using Float64, or could we\n            //       lose precision?\n            var intVal = (value << 24) | (value << 16) | (value << 8) | value;\n            for (i = 0; i < intBytes; i += 4) {\n                this.writeInt32LE(i + start, intVal);\n            }\n            for (i = intBytes; i < len; i++) {\n                this.writeUInt8(i + start, value);\n            }\n        };\n\n        /**\n        * Custom method for this buffer core. Get the backing object.\n        */\n        BufferCoreArrayBuffer.prototype.getDataView = function () {\n            return this.buff;\n        };\n        return BufferCoreArrayBuffer;\n    })(buffer_core.BufferCoreCommon);\n    exports.BufferCoreArrayBuffer = BufferCoreArrayBuffer;\n\n    // Type-check the class.\n    var _ = BufferCoreArrayBuffer;\n});\n//# sourceMappingURL=buffer_core_arraybuffer.js.map\n;\n","define('core/string_util',[\"require\", \"exports\"], function(require, exports) {\n    \n\n    /**\n    * Find the 'utility' object for the given string encoding. Throws an exception\n    * if the encoding is invalid.\n    * @param [String] encoding a string encoding\n    * @return [BrowserFS.StringUtil.*] The StringUtil object for the given encoding\n    */\n    function FindUtil(encoding) {\n        encoding = (function () {\n            switch (typeof encoding) {\n                case 'object':\n                    return \"\" + encoding;\n                case 'string':\n                    return encoding;\n                default:\n                    throw new Error('Invalid encoding argument specified');\n            }\n        })();\n        encoding = encoding.toLowerCase();\n\n        switch (encoding) {\n            case 'utf8':\n            case 'utf-8':\n                return UTF8;\n            case 'ascii':\n                return ASCII;\n            case 'binary':\n                return BINARY;\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n                return UCS2;\n            case 'hex':\n                return HEX;\n            case 'base64':\n                return BASE64;\n\n            case 'binary_string':\n                return BINSTR;\n            case 'binary_string_ie':\n                return BINSTRIE;\n            case 'extended_ascii':\n                return ExtendedASCII;\n\n            default:\n                throw new Error(\"Unknown encoding: \" + encoding);\n        }\n    }\n    exports.FindUtil = FindUtil;\n\n    /**\n    * String utility functions for UTF-8. Note that some UTF-8 strings *cannot* be\n    * expressed in terms of JavaScript UTF-16 strings.\n    * @see http://en.wikipedia.org/wiki/UTF-8\n    */\n    var UTF8 = (function () {\n        function UTF8() {\n        }\n        UTF8.str2byte = function (str, buf) {\n            var length = buf.length;\n            var i = 0;\n            var j = 0;\n            var maxJ = length;\n            var rv = [];\n            var numChars = 0;\n            while (i < str.length && j < maxJ) {\n                var code = str.charCodeAt(i++);\n                var next = str.charCodeAt(i);\n                if (0xD800 <= code && code <= 0xDBFF && 0xDC00 <= next && next <= 0xDFFF) {\n                    // 4 bytes: Surrogate pairs! UTF-16 fun time.\n                    if (j + 3 >= maxJ) {\n                        break;\n                    } else {\n                        numChars++;\n                    }\n\n                    // First pair: 10 bits of data, with an implicitly set 11th bit\n                    // Second pair: 10 bits of data\n                    var codePoint = (((code & 0x3FF) | 0x400) << 10) | (next & 0x3FF);\n\n                    // Highest 3 bits in first byte\n                    buf.writeUInt8((codePoint >> 18) | 0xF0, j++);\n\n                    // Rest are all 6 bits\n                    buf.writeUInt8(((codePoint >> 12) & 0x3F) | 0x80, j++);\n                    buf.writeUInt8(((codePoint >> 6) & 0x3F) | 0x80, j++);\n                    buf.writeUInt8((codePoint & 0x3F) | 0x80, j++);\n                    i++;\n                } else if (code < 0x80) {\n                    // One byte\n                    buf.writeUInt8(code, j++);\n                    numChars++;\n                } else if (code < 0x800) {\n                    // Two bytes\n                    if (j + 1 >= maxJ) {\n                        break;\n                    } else {\n                        numChars++;\n                    }\n\n                    // Highest 5 bits in first byte\n                    buf.writeUInt8((code >> 6) | 0xC0, j++);\n\n                    // Lower 6 bits in second byte\n                    buf.writeUInt8((code & 0x3F) | 0x80, j++);\n                } else if (code < 0x10000) {\n                    // Three bytes\n                    if (j + 2 >= maxJ) {\n                        break;\n                    } else {\n                        numChars++;\n                    }\n\n                    // Highest 4 bits in first byte\n                    buf.writeUInt8((code >> 12) | 0xE0, j++);\n\n                    // Middle 6 bits in second byte\n                    buf.writeUInt8(((code >> 6) & 0x3F) | 0x80, j++);\n\n                    // Lowest 6 bits in third byte\n                    buf.writeUInt8((code & 0x3F) | 0x80, j++);\n                }\n            }\n            return j;\n        };\n\n        UTF8.byte2str = function (buff) {\n            var chars = [];\n            var i = 0;\n            while (i < buff.length) {\n                var code = buff.readUInt8(i++);\n                if (code < 0x80) {\n                    chars.push(String.fromCharCode(code));\n                } else if (code < 0xC0) {\n                    throw new Error('Found incomplete part of character in string.');\n                } else if (code < 0xE0) {\n                    // 2 bytes: 5 and 6 bits\n                    chars.push(String.fromCharCode(((code & 0x1F) << 6) | (buff.readUInt8(i++) & 0x3F)));\n                } else if (code < 0xF0) {\n                    // 3 bytes: 4, 6, and 6 bits\n                    chars.push(String.fromCharCode(((code & 0xF) << 12) | ((buff.readUInt8(i++) & 0x3F) << 6) | (buff.readUInt8(i++) & 0x3F)));\n                } else if (code < 0xF8) {\n                    // 4 bytes: 3, 6, 6, 6 bits; surrogate pairs time!\n                    // First 11 bits; remove 11th bit as per UTF-16 standard\n                    var byte3 = buff.readUInt8(i + 2);\n                    chars.push(String.fromCharCode(((((code & 0x7) << 8) | ((buff.readUInt8(i++) & 0x3F) << 2) | ((buff.readUInt8(i++) & 0x3F) >> 4)) & 0x3FF) | 0xD800));\n\n                    // Final 10 bits\n                    chars.push(String.fromCharCode((((byte3 & 0xF) << 6) | (buff.readUInt8(i++) & 0x3F)) | 0xDC00));\n                } else {\n                    throw new Error('Unable to represent UTF-8 string as UTF-16 JavaScript string.');\n                }\n            }\n            return chars.join('');\n        };\n\n        UTF8.byteLength = function (str) {\n            // Matches only the 10.. bytes that are non-initial characters in a\n            // multi-byte sequence.\n            // @todo This may be slower than iterating through the string in some cases.\n            var m = encodeURIComponent(str).match(/%[89ABab]/g);\n            return str.length + (m ? m.length : 0);\n        };\n        return UTF8;\n    })();\n    exports.UTF8 = UTF8;\n\n    /**\n    * String utility functions for 8-bit ASCII. Like Node, we mask the high bits of\n    * characters in JavaScript UTF-16 strings.\n    * @see http://en.wikipedia.org/wiki/ASCII\n    */\n    var ASCII = (function () {\n        function ASCII() {\n        }\n        ASCII.str2byte = function (str, buf) {\n            var length = str.length > buf.length ? buf.length : str.length;\n            for (var i = 0; i < length; i++) {\n                buf.writeUInt8(str.charCodeAt(i) % 256, i);\n            }\n            return length;\n        };\n\n        ASCII.byte2str = function (buff) {\n            var chars = new Array(buff.length);\n            for (var i = 0; i < buff.length; i++) {\n                chars[i] = String.fromCharCode(buff.readUInt8(i) & 0x7F);\n            }\n            return chars.join('');\n        };\n\n        ASCII.byteLength = function (str) {\n            return str.length;\n        };\n        return ASCII;\n    })();\n    exports.ASCII = ASCII;\n\n    /**\n    * (Nonstandard) String utility function for 8-bit ASCII with the extended\n    * character set. Unlike the ASCII above, we do not mask the high bits.\n    * @see http://en.wikipedia.org/wiki/Extended_ASCII\n    */\n    var ExtendedASCII = (function () {\n        function ExtendedASCII() {\n        }\n        ExtendedASCII.str2byte = function (str, buf) {\n            var length = str.length > buf.length ? buf.length : str.length;\n            for (var i = 0; i < length; i++) {\n                var charCode = str.charCodeAt(i);\n                if (charCode > 0x7F) {\n                    // Check if extended ASCII.\n                    var charIdx = ExtendedASCII.extendedChars.indexOf(str.charAt(i));\n                    if (charIdx > -1) {\n                        charCode = charIdx + 0x80;\n                    }\n                    // Otherwise, keep it as-is.\n                }\n                buf.writeUInt8(charCode, i);\n            }\n            return length;\n        };\n\n        ExtendedASCII.byte2str = function (buff) {\n            var chars = new Array(buff.length);\n            for (var i = 0; i < buff.length; i++) {\n                var charCode = buff.readUInt8(i);\n                if (charCode > 0x7F) {\n                    chars[i] = ExtendedASCII.extendedChars[charCode - 128];\n                } else {\n                    chars[i] = String.fromCharCode(charCode);\n                }\n            }\n            return chars.join('');\n        };\n\n        ExtendedASCII.byteLength = function (str) {\n            return str.length;\n        };\n        ExtendedASCII.extendedChars = [\n            '\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4',\n            '\\u00E0', '\\u00E5', '\\u00E7', '\\u00EA', '\\u00EB', '\\u00E8', '\\u00EF',\n            '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5', '\\u00C9', '\\u00E6', '\\u00C6',\n            '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9', '\\u00FF', '\\u00D6',\n            '\\u00DC', '\\u00F8', '\\u00A3', '\\u00D8', '\\u00D7', '\\u0192', '\\u00E1',\n            '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1', '\\u00AA', '\\u00BA',\n            '\\u00BF', '\\u00AE', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB',\n            '\\u00BB', '_', '_', '_', '\\u00A6', '\\u00A6', '\\u00C1', '\\u00C2', '\\u00C0',\n            '\\u00A9', '\\u00A6', '\\u00A6', '+', '+', '\\u00A2', '\\u00A5', '+', '+', '-',\n            '-', '+', '-', '+', '\\u00E3', '\\u00C3', '+', '+', '-', '-', '\\u00A6', '-',\n            '+', '\\u00A4', '\\u00F0', '\\u00D0', '\\u00CA', '\\u00CB', '\\u00C8', 'i',\n            '\\u00CD', '\\u00CE', '\\u00CF', '+', '+', '_', '_', '\\u00A6', '\\u00CC', '_',\n            '\\u00D3', '\\u00DF', '\\u00D4', '\\u00D2', '\\u00F5', '\\u00D5', '\\u00B5',\n            '\\u00FE', '\\u00DE', '\\u00DA', '\\u00DB', '\\u00D9', '\\u00FD', '\\u00DD',\n            '\\u00AF', '\\u00B4', '\\u00AD', '\\u00B1', '_', '\\u00BE', '\\u00B6', '\\u00A7',\n            '\\u00F7', '\\u00B8', '\\u00B0', '\\u00A8', '\\u00B7', '\\u00B9', '\\u00B3',\n            '\\u00B2', '_', ' '];\n        return ExtendedASCII;\n    })();\n    exports.ExtendedASCII = ExtendedASCII;\n\n    /**\n    * String utility functions for Node's BINARY strings, which represent a single\n    * byte per character.\n    */\n    var BINARY = (function () {\n        function BINARY() {\n        }\n        BINARY.str2byte = function (str, buf) {\n            var length = str.length > buf.length ? buf.length : str.length;\n            for (var i = 0; i < length; i++) {\n                buf.writeUInt8(str.charCodeAt(i) & 0xFF, i);\n            }\n            return length;\n        };\n\n        BINARY.byte2str = function (buff) {\n            var chars = new Array(buff.length);\n            for (var i = 0; i < buff.length; i++) {\n                chars[i] = String.fromCharCode(buff.readUInt8(i) & 0xFF);\n            }\n            return chars.join('');\n        };\n\n        BINARY.byteLength = function (str) {\n            return str.length;\n        };\n        return BINARY;\n    })();\n    exports.BINARY = BINARY;\n\n    /**\n    * Contains string utility functions for base-64 encoding.\n    *\n    * Adapted from the StackOverflow comment linked below.\n    * @see http://stackoverflow.com/questions/246801/how-can-you-encode-to-base64-using-javascript#246813\n    * @see http://en.wikipedia.org/wiki/Base64\n    * @todo Bake in support for btoa() and atob() if available.\n    */\n    var BASE64 = (function () {\n        function BASE64() {\n        }\n        BASE64.byte2str = function (buff) {\n            var output = '';\n            var i = 0;\n            while (i < buff.length) {\n                var chr1 = buff.readUInt8(i++);\n                var chr2 = i < buff.length ? buff.readUInt8(i++) : NaN;\n                var chr3 = i < buff.length ? buff.readUInt8(i++) : NaN;\n                var enc1 = chr1 >> 2;\n                var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n                var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n                var enc4 = chr3 & 63;\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n                output = output + BASE64.num2b64[enc1] + BASE64.num2b64[enc2] + BASE64.num2b64[enc3] + BASE64.num2b64[enc4];\n            }\n            return output;\n        };\n\n        BASE64.str2byte = function (str, buf) {\n            var length = buf.length;\n            var output = '';\n            var i = 0;\n            str = str.replace(/[^A-Za-z0-9\\+\\/\\=\\-\\_]/g, '');\n            var j = 0;\n            while (i < str.length) {\n                var enc1 = BASE64.b642num[str.charAt(i++)];\n                var enc2 = BASE64.b642num[str.charAt(i++)];\n                var enc3 = BASE64.b642num[str.charAt(i++)];\n                var enc4 = BASE64.b642num[str.charAt(i++)];\n                var chr1 = (enc1 << 2) | (enc2 >> 4);\n                var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n                var chr3 = ((enc3 & 3) << 6) | enc4;\n                buf.writeUInt8(chr1, j++);\n                if (j === length) {\n                    break;\n                }\n                if (enc3 !== 64) {\n                    output += buf.writeUInt8(chr2, j++);\n                }\n                if (j === length) {\n                    break;\n                }\n                if (enc4 !== 64) {\n                    output += buf.writeUInt8(chr3, j++);\n                }\n                if (j === length) {\n                    break;\n                }\n            }\n            return j;\n        };\n\n        BASE64.byteLength = function (str) {\n            return Math.floor(((str.replace(/[^A-Za-z0-9\\+\\/\\-\\_]/g, '')).length * 6) / 8);\n        };\n        BASE64.b64chars = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', '='];\n        BASE64.num2b64 = (function () {\n            var obj = new Array(BASE64.b64chars.length);\n            for (var idx = 0; idx < BASE64.b64chars.length; idx++) {\n                var i = BASE64.b64chars[idx];\n                obj[idx] = i;\n            }\n            return obj;\n        })();\n\n        BASE64.b642num = (function () {\n            var obj = {};\n            for (var idx = 0; idx < BASE64.b64chars.length; idx++) {\n                var i = BASE64.b64chars[idx];\n                obj[i] = idx;\n            }\n            obj['-'] = 62;\n            obj['_'] = 63;\n            return obj;\n        })();\n        return BASE64;\n    })();\n    exports.BASE64 = BASE64;\n\n    /**\n    * String utility functions for the UCS-2 encoding. Note that our UCS-2 handling\n    * is identical to our UTF-16 handling.\n    *\n    * Note: UCS-2 handling is identical to UTF-16.\n    * @see http://en.wikipedia.org/wiki/UCS2\n    */\n    var UCS2 = (function () {\n        function UCS2() {\n        }\n        UCS2.str2byte = function (str, buf) {\n            var len = str.length;\n\n            // Clip length to longest string of valid characters that can fit in the\n            // byte range.\n            if (len * 2 > buf.length) {\n                len = buf.length % 2 === 1 ? (buf.length - 1) / 2 : buf.length / 2;\n            }\n            for (var i = 0; i < len; i++) {\n                buf.writeUInt16LE(str.charCodeAt(i), i * 2);\n            }\n            return len * 2;\n        };\n\n        UCS2.byte2str = function (buff) {\n            if (buff.length % 2 !== 0) {\n                throw new Error('Invalid UCS2 byte array.');\n            }\n            var chars = new Array(buff.length / 2);\n            for (var i = 0; i < buff.length; i += 2) {\n                chars[i / 2] = String.fromCharCode(buff.readUInt8(i) | (buff.readUInt8(i + 1) << 8));\n            }\n            return chars.join('');\n        };\n\n        UCS2.byteLength = function (str) {\n            return str.length * 2;\n        };\n        return UCS2;\n    })();\n    exports.UCS2 = UCS2;\n\n    /**\n    * Contains string utility functions for hex encoding.\n    * @see http://en.wikipedia.org/wiki/Hexadecimal\n    */\n    var HEX = (function () {\n        function HEX() {\n        }\n        HEX.str2byte = function (str, buf) {\n            if (str.length % 2 === 1) {\n                throw new Error('Invalid hex string');\n            }\n\n            // Each character is 1 byte encoded as two hex characters; so 1 byte becomes\n            // 2 bytes.\n            var numBytes = str.length >> 1;\n            if (numBytes > buf.length) {\n                numBytes = buf.length;\n            }\n            for (var i = 0; i < numBytes; i++) {\n                var char1 = this.hex2num[str.charAt(i << 1)];\n                var char2 = this.hex2num[str.charAt((i << 1) + 1)];\n                buf.writeUInt8((char1 << 4) | char2, i);\n            }\n            return numBytes;\n        };\n\n        HEX.byte2str = function (buff) {\n            var len = buff.length;\n            var chars = new Array(len << 1);\n            var j = 0;\n            for (var i = 0; i < len; i++) {\n                var hex2 = buff.readUInt8(i) & 0xF;\n                var hex1 = buff.readUInt8(i) >> 4;\n                chars[j++] = this.num2hex[hex1];\n                chars[j++] = this.num2hex[hex2];\n            }\n            return chars.join('');\n        };\n\n        HEX.byteLength = function (str) {\n            // Assuming a valid string.\n            return str.length >> 1;\n        };\n        HEX.HEXCHARS = '0123456789abcdef';\n\n        HEX.num2hex = (function () {\n            var obj = new Array(HEX.HEXCHARS.length);\n            for (var idx = 0; idx < HEX.HEXCHARS.length; idx++) {\n                var i = HEX.HEXCHARS[idx];\n                obj[idx] = i;\n            }\n            return obj;\n        })();\n\n        HEX.hex2num = (function () {\n            var idx, i;\n            var obj = {};\n            for (idx = 0; idx < HEX.HEXCHARS.length; idx++) {\n                i = HEX.HEXCHARS[idx];\n                obj[i] = idx;\n            }\n            var capitals = 'ABCDEF';\n            for (idx = 0; idx < capitals.length; idx++) {\n                i = capitals[idx];\n                obj[i] = idx + 10;\n            }\n            return obj;\n        })();\n        return HEX;\n    })();\n    exports.HEX = HEX;\n\n    /**\n    * Contains string utility functions for binary string encoding. This is where we\n    * pack arbitrary binary data as a UTF-16 string.\n    *\n    * Each character in the string is two bytes. The first character in the string\n    * is special: The first byte specifies if the binary data is of odd byte length.\n    * If it is, then it is a 1 and the second byte is the first byte of data; if\n    * not, it is a 0 and the second byte is 0.\n    *\n    * Everything is little endian.\n    */\n    var BINSTR = (function () {\n        function BINSTR() {\n        }\n        BINSTR.str2byte = function (str, buf) {\n            // Special case: Empty string\n            if (str.length === 0) {\n                return 0;\n            }\n            var numBytes = BINSTR.byteLength(str);\n            if (numBytes > buf.length) {\n                numBytes = buf.length;\n            }\n            var j = 0;\n            var startByte = 0;\n            var endByte = startByte + numBytes;\n\n            // Handle first character separately\n            var firstChar = str.charCodeAt(j++);\n            if (firstChar !== 0) {\n                buf.writeUInt8(firstChar & 0xFF, 0);\n                startByte = 1;\n            }\n            for (var i = startByte; i < endByte; i += 2) {\n                var chr = str.charCodeAt(j++);\n                if (endByte - i === 1) {\n                    // Write first byte of character\n                    buf.writeUInt8(chr >> 8, i);\n                }\n                if (endByte - i >= 2) {\n                    // Write both bytes in character\n                    buf.writeUInt16BE(chr, i);\n                }\n            }\n            return numBytes;\n        };\n\n        BINSTR.byte2str = function (buff) {\n            var len = buff.length;\n\n            // Special case: Empty string\n            if (len === 0) {\n                return '';\n            }\n            var chars = new Array((len >> 1) + 1);\n            var j = 0;\n            for (var i = 0; i < chars.length; i++) {\n                if (i === 0) {\n                    if (len % 2 === 1) {\n                        chars[i] = String.fromCharCode((1 << 8) | buff.readUInt8(j++));\n                    } else {\n                        chars[i] = String.fromCharCode(0);\n                    }\n                } else {\n                    chars[i] = String.fromCharCode((buff.readUInt8(j++) << 8) | buff.readUInt8(j++));\n                }\n            }\n            return chars.join('');\n        };\n\n        BINSTR.byteLength = function (str) {\n            if (str.length === 0) {\n                // Special case: Empty string.\n                return 0;\n            }\n            var firstChar = str.charCodeAt(0);\n            var bytelen = (str.length - 1) << 1;\n            if (firstChar !== 0) {\n                bytelen++;\n            }\n            return bytelen;\n        };\n        return BINSTR;\n    })();\n    exports.BINSTR = BINSTR;\n\n    /**\n    * IE/older FF version of binary string. One byte per character, offset by 0x20.\n    */\n    var BINSTRIE = (function () {\n        function BINSTRIE() {\n        }\n        BINSTRIE.str2byte = function (str, buf) {\n            var length = str.length > buf.length ? buf.length : str.length;\n            for (var i = 0; i < length; i++) {\n                buf.writeUInt8(str.charCodeAt(i) - 0x20, i);\n            }\n            return length;\n        };\n\n        BINSTRIE.byte2str = function (buff) {\n            var chars = new Array(buff.length);\n            for (var i = 0; i < buff.length; i++) {\n                chars[i] = String.fromCharCode(buff.readUInt8(i) + 0x20);\n            }\n            return chars.join('');\n        };\n\n        BINSTRIE.byteLength = function (str) {\n            return str.length;\n        };\n        return BINSTRIE;\n    })();\n    exports.BINSTRIE = BINSTRIE;\n});\n//# sourceMappingURL=string_util.js.map\n;\n","define('core/buffer',[\"require\", \"exports\", './buffer_core', './buffer_core_array', './buffer_core_arraybuffer', './buffer_core_imagedata', './string_util'], function(require, exports, buffer_core, buffer_core_array, buffer_core_arraybuffer, buffer_core_imagedata, string_util) {\n    // BC implementations earlier in the array are preferred.\n    var BufferCorePreferences = [\n        buffer_core_arraybuffer.BufferCoreArrayBuffer,\n        buffer_core_imagedata.BufferCoreImageData,\n        buffer_core_array.BufferCoreArray\n    ];\n\n    var PreferredBufferCore = (function () {\n        var i, bci;\n        for (i = 0; i < BufferCorePreferences.length; i++) {\n            bci = BufferCorePreferences[i];\n            if (bci.isAvailable())\n                return bci;\n        }\n\n        throw new Error(\"This browser does not support any available BufferCore implementations.\");\n    })();\n\n    \n\n    \n\n    /**\n    * Emulates Node's Buffer API. Wraps a BufferCore object that is responsible\n    * for actually writing/reading data from some data representation in memory.\n    */\n    var Buffer = (function () {\n        function Buffer(arg1, arg2, arg3) {\n            if (typeof arg2 === \"undefined\") { arg2 = 'utf8'; }\n            this.offset = 0;\n            var i;\n\n            // Node apparently allows you to construct buffers w/o 'new'.\n            if (!(this instanceof Buffer)) {\n                return new Buffer(arg1, arg2);\n            }\n\n            if (arg1 instanceof buffer_core.BufferCoreCommon) {\n                // constructor (data: buffer_core.BufferCore, start?: number, end?: number)\n                this.data = arg1;\n                var start = typeof arg2 === 'number' ? arg2 : 0;\n                var end = typeof arg3 === 'number' ? arg3 : this.data.getLength();\n                this.offset = start;\n                this.length = end - start;\n            } else if (typeof arg1 === 'number') {\n                // constructor (size: number);\n                if (arg1 !== (arg1 >>> 0)) {\n                    throw new TypeError('Buffer size must be a uint32.');\n                }\n                this.length = arg1;\n                this.data = new PreferredBufferCore(arg1);\n            } else if (typeof DataView !== 'undefined' && arg1 instanceof DataView) {\n                // constructor (data: DataView);\n                this.data = new buffer_core_arraybuffer.BufferCoreArrayBuffer(arg1);\n                this.length = arg1.byteLength;\n            } else if (typeof ArrayBuffer !== 'undefined' && arg1 instanceof ArrayBuffer) {\n                // constructor (data: ArrayBuffer);\n                this.data = new buffer_core_arraybuffer.BufferCoreArrayBuffer(arg1);\n                this.length = arg1.byteLength;\n            } else if (arg1 instanceof Buffer) {\n                // constructor (data: Buffer);\n                var argBuff = arg1;\n                this.data = new PreferredBufferCore(arg1.length);\n                this.length = arg1.length;\n                argBuff.copy(this);\n            } else if (Array.isArray(arg1) || (arg1 != null && typeof arg1 === 'object' && typeof arg1[0] === 'number')) {\n                // constructor (data: number[]);\n                this.data = new PreferredBufferCore(arg1.length);\n                for (i = 0; i < arg1.length; i++) {\n                    this.data.writeUInt8(i, arg1[i]);\n                }\n                this.length = arg1.length;\n            } else if (typeof arg1 === 'string') {\n                // constructor (data: string, encoding?: string);\n                this.length = Buffer.byteLength(arg1, arg2);\n                this.data = new PreferredBufferCore(this.length);\n                this.write(arg1, 0, this.length, arg2);\n            } else {\n                throw new Error(\"Invalid argument to Buffer constructor: \" + arg1);\n            }\n        }\n        Buffer.prototype.getBufferCore = function () {\n            return this.data;\n        };\n\n        Buffer.prototype.getOffset = function () {\n            return this.offset;\n        };\n\n        /**\n        * **NONSTANDARD**: Set the octet at index. Emulates NodeJS buffer's index\n        * operation. Octet can be signed or unsigned.\n        * @param {number} index - the index to set the value at\n        * @param {number} value - the value to set at the given index\n        */\n        Buffer.prototype.set = function (index, value) {\n            // In Node, the following happens:\n            // buffer[0] = -1;\n            // buffer[0]; // 255\n            if (value < 0) {\n                return this.writeInt8(value, index);\n            } else {\n                return this.writeUInt8(value, index);\n            }\n        };\n\n        /**\n        * **NONSTANDARD**: Get the octet at index.\n        * @param {number} index - index to fetch the value at\n        * @return {number} the value at the given index\n        */\n        Buffer.prototype.get = function (index) {\n            return this.readUInt8(index);\n        };\n\n        /**\n        * Writes string to the buffer at offset using the given encoding.\n        * If buffer did not contain enough space to fit the entire string, it will\n        * write a partial amount of the string.\n        * @param {string} str - Data to be written to buffer\n        * @param {number} [offset=0] - Offset in the buffer to write to\n        * @param {number} [length=this.length] - Number of bytes to write\n        * @param {string} [encoding=utf8] - Character encoding\n        * @return {number} Number of octets written.\n        */\n        Buffer.prototype.write = function (str, offset, length, encoding) {\n            if (typeof offset === \"undefined\") { offset = 0; }\n            if (typeof length === \"undefined\") { length = this.length; }\n            if (typeof encoding === \"undefined\") { encoding = 'utf8'; }\n            // I hate Node's optional arguments.\n            if (typeof offset === 'string') {\n                // 'str' and 'encoding' specified\n                encoding = \"\" + offset;\n                offset = 0;\n                length = this.length;\n            } else if (typeof length === 'string') {\n                // 'str', 'offset', and 'encoding' specified\n                encoding = \"\" + length;\n                length = this.length;\n            }\n\n            // Don't waste our time if the offset is beyond the buffer length\n            if (offset >= this.length) {\n                return 0;\n            }\n            var strUtil = string_util.FindUtil(encoding);\n\n            // Are we trying to write past the buffer?\n            length = length + offset > this.length ? this.length - offset : length;\n            offset += this.offset;\n            return strUtil.str2byte(str, offset === 0 && length === this.length ? this : new Buffer(this.data, offset, length + offset));\n        };\n\n        /**\n        * Decodes a portion of the Buffer into a String.\n        * @param {string} encoding - Character encoding to decode to\n        * @param {number} [start=0] - Start position in the buffer\n        * @param {number} [end=this.length] - Ending position in the buffer\n        * @return {string} A string from buffer data encoded with encoding, beginning\n        *   at start, and ending at end.\n        */\n        Buffer.prototype.toString = function (encoding, start, end) {\n            if (typeof encoding === \"undefined\") { encoding = 'utf8'; }\n            if (typeof start === \"undefined\") { start = 0; }\n            if (typeof end === \"undefined\") { end = this.length; }\n            if (!(start <= end)) {\n                throw new Error(\"Invalid start/end positions: \" + start + \" - \" + end);\n            }\n            if (start === end) {\n                return '';\n            }\n            if (end > this.length) {\n                end = this.length;\n            }\n            var strUtil = string_util.FindUtil(encoding);\n\n            // Get the string representation of the given slice. Create a new buffer\n            // if need be.\n            return strUtil.byte2str(start === 0 && end === this.length ? this : new Buffer(this.data, start + this.offset, end + this.offset));\n        };\n\n        /**\n        * Returns a JSON-representation of the Buffer instance, which is identical to\n        * the output for JSON Arrays. JSON.stringify implicitly calls this function\n        * when stringifying a Buffer instance.\n        * @return {object} An object that can be used for JSON stringification.\n        */\n        Buffer.prototype.toJSON = function () {\n            // Construct a byte array for the JSON 'data'.\n            var len = this.length;\n            var byteArr = new Array(len);\n            for (var i = 0; i < len; i++) {\n                byteArr[i] = this.readUInt8(i);\n            }\n            return {\n                type: 'Buffer',\n                data: byteArr\n            };\n        };\n\n        /**\n        * Does copy between buffers. The source and target regions can be overlapped.\n        * All values passed that are undefined/NaN or are out of bounds are set equal\n        * to their respective defaults.\n        * @param {Buffer} target - Buffer to copy into\n        * @param {number} [targetStart=0] - Index to start copying to in the targetBuffer\n        * @param {number} [sourceStart=0] - Index in this buffer to start copying from\n        * @param {number} [sourceEnd=this.length] - Index in this buffer stop copying at\n        * @return {number} The number of bytes copied into the target buffer.\n        */\n        Buffer.prototype.copy = function (target, targetStart, sourceStart, sourceEnd) {\n            if (typeof targetStart === \"undefined\") { targetStart = 0; }\n            if (typeof sourceStart === \"undefined\") { sourceStart = 0; }\n            if (typeof sourceEnd === \"undefined\") { sourceEnd = this.length; }\n            // The Node code is weird. It sets some out-of-bounds args to their defaults\n            // and throws exceptions for others (sourceEnd).\n            targetStart = targetStart < 0 ? 0 : targetStart;\n            sourceStart = sourceStart < 0 ? 0 : sourceStart;\n\n            // Need to sanity check all of the input. Node has really odd rules regarding\n            // when to apply default arguments. I decided to copy Node's logic.\n            if (sourceEnd < sourceStart) {\n                throw new RangeError('sourceEnd < sourceStart');\n            }\n            if (sourceEnd === sourceStart) {\n                return 0;\n            }\n            if (targetStart >= target.length) {\n                throw new RangeError('targetStart out of bounds');\n            }\n            if (sourceStart >= this.length) {\n                throw new RangeError('sourceStart out of bounds');\n            }\n            if (sourceEnd > this.length) {\n                throw new RangeError('sourceEnd out of bounds');\n            }\n            var bytesCopied = Math.min(sourceEnd - sourceStart, target.length - targetStart, this.length - sourceStart);\n\n            for (var i = 0; i < bytesCopied; i++) {\n                target.writeUInt8(this.readUInt8(sourceStart + i), targetStart + i);\n            }\n            return bytesCopied;\n        };\n\n        /**\n        * Returns a slice of this buffer.\n        * @param {number} [start=0] - Index to start slicing from\n        * @param {number} [end=this.length] - Index to stop slicing at\n        * @return {Buffer} A new buffer which references the same\n        *   memory as the old, but offset and cropped by the start (defaults to 0) and\n        *   end (defaults to buffer.length) indexes. Negative indexes start from the end\n        *   of the buffer.\n        */\n        Buffer.prototype.slice = function (start, end) {\n            if (typeof start === \"undefined\") { start = 0; }\n            if (typeof end === \"undefined\") { end = this.length; }\n            // Translate negative indices to positive ones.\n            if (start < 0) {\n                start += this.length;\n                if (start < 0) {\n                    start = 0;\n                }\n            }\n            if (end < 0) {\n                end += this.length;\n                if (end < 0) {\n                    end = 0;\n                }\n            }\n            if (end > this.length) {\n                end = this.length;\n            }\n            if (start > end) {\n                start = end;\n            }\n\n            // Sanity check.\n            if (start < 0 || end < 0 || start >= this.length || end > this.length) {\n                throw new Error(\"Invalid slice indices.\");\n            }\n\n            // Create a new buffer backed by the same BufferCore.\n            return new Buffer(this.data, start + this.offset, end + this.offset);\n        };\n\n        /**\n        * [NONSTANDARD] A copy-based version of Buffer.slice.\n        */\n        Buffer.prototype.sliceCopy = function (start, end) {\n            if (typeof start === \"undefined\") { start = 0; }\n            if (typeof end === \"undefined\") { end = this.length; }\n            // Translate negative indices to positive ones.\n            if (start < 0) {\n                start += this.length;\n                if (start < 0) {\n                    start = 0;\n                }\n            }\n            if (end < 0) {\n                end += this.length;\n                if (end < 0) {\n                    end = 0;\n                }\n            }\n            if (end > this.length) {\n                end = this.length;\n            }\n            if (start > end) {\n                start = end;\n            }\n\n            // Sanity check.\n            if (start < 0 || end < 0 || start >= this.length || end > this.length) {\n                throw new Error(\"Invalid slice indices.\");\n            }\n\n            // Copy the BufferCore.\n            return new Buffer(this.data.copy(start + this.offset, end + this.offset));\n        };\n\n        /**\n        * Fills the buffer with the specified value. If the offset and end are not\n        * given it will fill the entire buffer.\n        * @param {(string|number)} value - The value to fill the buffer with\n        * @param {number} [offset=0]\n        * @param {number} [end=this.length]\n        */\n        Buffer.prototype.fill = function (value, offset, end) {\n            if (typeof offset === \"undefined\") { offset = 0; }\n            if (typeof end === \"undefined\") { end = this.length; }\n            var i;\n            var valType = typeof value;\n            switch (valType) {\n                case \"string\":\n                    // Trim to a byte.\n                    value = value.charCodeAt(0) & 0xFF;\n                    break;\n                case \"number\":\n                    break;\n                default:\n                    throw new Error('Invalid argument to fill.');\n            }\n            offset += this.offset;\n            end += this.offset;\n            this.data.fill(value, offset, end);\n        };\n\n        Buffer.prototype.readUInt8 = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readUInt8(offset);\n        };\n\n        Buffer.prototype.readUInt16LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readUInt16LE(offset);\n        };\n\n        Buffer.prototype.readUInt16BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readUInt16BE(offset);\n        };\n\n        Buffer.prototype.readUInt32LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readUInt32LE(offset);\n        };\n\n        Buffer.prototype.readUInt32BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readUInt32BE(offset);\n        };\n\n        Buffer.prototype.readInt8 = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readInt8(offset);\n        };\n\n        Buffer.prototype.readInt16LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readInt16LE(offset);\n        };\n\n        Buffer.prototype.readInt16BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readInt16BE(offset);\n        };\n\n        Buffer.prototype.readInt32LE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readInt32LE(offset);\n        };\n\n        Buffer.prototype.readInt32BE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readInt32BE(offset);\n        };\n\n        Buffer.prototype.readFloatLE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readFloatLE(offset);\n        };\n\n        Buffer.prototype.readFloatBE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readFloatBE(offset);\n        };\n\n        Buffer.prototype.readDoubleLE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readDoubleLE(offset);\n        };\n\n        Buffer.prototype.readDoubleBE = function (offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            return this.data.readDoubleBE(offset);\n        };\n\n        Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeUInt8(offset, value);\n        };\n\n        Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeUInt16LE(offset, value);\n        };\n\n        Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeUInt16BE(offset, value);\n        };\n\n        Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeUInt32LE(offset, value);\n        };\n\n        Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeUInt32BE(offset, value);\n        };\n\n        Buffer.prototype.writeInt8 = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeInt8(offset, value);\n        };\n\n        Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeInt16LE(offset, value);\n        };\n\n        Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeInt16BE(offset, value);\n        };\n\n        Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeInt32LE(offset, value);\n        };\n\n        Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeInt32BE(offset, value);\n        };\n\n        Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeFloatLE(offset, value);\n        };\n\n        Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeFloatBE(offset, value);\n        };\n\n        Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeDoubleLE(offset, value);\n        };\n\n        Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n            if (typeof noAssert === \"undefined\") { noAssert = false; }\n            offset += this.offset;\n            this.data.writeDoubleBE(offset, value);\n        };\n\n        ///**************************STATIC METHODS********************************///\n        /**\n        * Checks if enc is a valid string encoding type.\n        * @param {string} enc - Name of a string encoding type.\n        * @return {boolean} Whether or not enc is a valid encoding type.\n        */\n        Buffer.isEncoding = function (enc) {\n            try  {\n                string_util.FindUtil(enc);\n            } catch (e) {\n                return false;\n            }\n            return true;\n        };\n\n        /**\n        * Tests if obj is a Buffer.\n        * @param {object} obj - An arbitrary object\n        * @return {boolean} True if this object is a Buffer.\n        */\n        Buffer.isBuffer = function (obj) {\n            return obj instanceof Buffer;\n        };\n\n        /**\n        * Gives the actual byte length of a string. This is not the same as\n        * String.prototype.length since that returns the number of characters in a\n        * string.\n        * @param {string} str - The string to get the byte length of\n        * @param {string} [encoding=utf8] - Character encoding of the string\n        * @return {number} The number of bytes in the string\n        */\n        Buffer.byteLength = function (str, encoding) {\n            if (typeof encoding === \"undefined\") { encoding = 'utf8'; }\n            var strUtil = string_util.FindUtil(encoding);\n            return strUtil.byteLength(str);\n        };\n\n        /**\n        * Returns a buffer which is the result of concatenating all the buffers in the\n        * list together.\n        * If the list has no items, or if the totalLength is 0, then it returns a\n        * zero-length buffer.\n        * If the list has exactly one item, then the first item of the list is\n        * returned.\n        * If the list has more than one item, then a new Buffer is created.\n        * If totalLength is not provided, it is read from the buffers in the list.\n        * However, this adds an additional loop to the function, so it is faster to\n        * provide the length explicitly.\n        * @param {Buffer[]} list - List of Buffer objects to concat\n        * @param {number} [totalLength] - Total length of the buffers when concatenated\n        * @return {Buffer}\n        */\n        Buffer.concat = function (list, totalLength) {\n            var item;\n            if (list.length === 0 || totalLength === 0) {\n                return new Buffer(0);\n            } else if (list.length === 1) {\n                return list[0];\n            } else {\n                if (totalLength == null) {\n                    // Calculate totalLength\n                    totalLength = 0;\n                    for (var i = 0; i < list.length; i++) {\n                        item = list[i];\n                        totalLength += item.length;\n                    }\n                }\n                var buf = new Buffer(totalLength);\n                var curPos = 0;\n                for (var j = 0; j < list.length; j++) {\n                    item = list[j];\n                    curPos += item.copy(buf, curPos);\n                }\n                return buf;\n            }\n        };\n        return Buffer;\n    })();\n    exports.Buffer = Buffer;\n\n    // Type-check the class.\n    var _ = Buffer;\n});\n//# sourceMappingURL=buffer.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/node_eventemitter',[\"require\", \"exports\", './buffer', './api_error'], function(require, exports, buffer, api_error) {\n    var Buffer = buffer.Buffer;\n    var ApiError = api_error.ApiError;\n    var ErrorCode = api_error.ErrorCode;\n\n    /**\n    * Internal class. Represents a buffered event.\n    */\n    var BufferedEvent = (function () {\n        function BufferedEvent(data, encoding, cb) {\n            this.data = data;\n            this.encoding = encoding;\n            this.cb = cb;\n            this.size = typeof (data) !== 'string' ? data.length : Buffer.byteLength(data, encoding != null ? encoding : undefined);\n\n            // If data is a buffer, we need to copy it.\n            if (typeof (this.data) !== 'string') {\n                this.data = this.data.sliceCopy();\n            }\n        }\n        BufferedEvent.prototype.getData = function (encoding) {\n            if (encoding == null) {\n                if (typeof (this.data) === 'string') {\n                    return new Buffer(this.data, this.encoding != null ? this.encoding : undefined);\n                } else {\n                    return this.data;\n                }\n            } else {\n                if (typeof (this.data) === 'string') {\n                    if (encoding === this.encoding) {\n                        return this.data;\n                    } else {\n                        return (new Buffer(this.data, this.encoding != null ? this.encoding : undefined)).toString(encoding);\n                    }\n                } else {\n                    return this.data.toString(encoding);\n                }\n            }\n        };\n        return BufferedEvent;\n    })();\n\n    /**\n    * Provides an abstract implementation of the EventEmitter interface.\n    */\n    var AbstractEventEmitter = (function () {\n        function AbstractEventEmitter() {\n            this._listeners = {};\n            this.maxListeners = 10;\n        }\n        /**\n        * Adds a listener for the particular event.\n        */\n        AbstractEventEmitter.prototype.addListener = function (event, listener) {\n            if (typeof (this._listeners[event]) === 'undefined') {\n                this._listeners[event] = [];\n            }\n            if (this._listeners[event].push(listener) > this.maxListeners) {\n                process.stdout.write(\"Warning: Event \" + event + \" has more than \" + this.maxListeners + \" listeners.\\n\");\n            }\n            this.emit('newListener', event, listener);\n            return this;\n        };\n\n        /**\n        * Adds a listener for the particular event.\n        */\n        AbstractEventEmitter.prototype.on = function (event, listener) {\n            return this.addListener(event, listener);\n        };\n\n        /**\n        * Adds a listener for the particular event that fires only once.\n        */\n        AbstractEventEmitter.prototype.once = function (event, listener) {\n            // Create a new callback that will only fire once.\n            var fired = false, newListener = function () {\n                this.removeListener(event, newListener);\n\n                if (!fired) {\n                    fired = true;\n                    listener.apply(this, arguments);\n                }\n            };\n            return this.addListener(event, newListener);\n        };\n\n        /**\n        * Emits the 'removeListener' event for the specified listeners.\n        */\n        AbstractEventEmitter.prototype._emitRemoveListener = function (event, listeners) {\n            var i;\n\n            // Only emit the event if someone is listening.\n            if (this._listeners['removeListener'] && this._listeners['removeListener'].length > 0) {\n                for (i = 0; i < listeners.length; i++) {\n                    this.emit('removeListener', event, listeners[i]);\n                }\n            }\n        };\n\n        /**\n        * Removes the particular listener for the given event.\n        */\n        AbstractEventEmitter.prototype.removeListener = function (event, listener) {\n            var listeners = this._listeners[event];\n            if (typeof (listeners) !== 'undefined') {\n                // Remove listener, if present.\n                var idx = listeners.indexOf(listener);\n                if (idx > -1) {\n                    listeners.splice(idx, 1);\n                }\n            }\n            this.emit('removeListener', event, listener);\n            return this;\n        };\n\n        /**\n        * Removes all listeners, or those of the specified event.\n        */\n        AbstractEventEmitter.prototype.removeAllListeners = function (event) {\n            var removed, keys, i;\n            if (typeof (event) !== 'undefined') {\n                removed = this._listeners[event];\n\n                // Clear one event.\n                this._listeners[event] = [];\n                this._emitRemoveListener(event, removed);\n            } else {\n                // Clear all events.\n                keys = Object.keys(this._listeners);\n                for (i = 0; i < keys.length; i++) {\n                    this.removeAllListeners(keys[i]);\n                }\n            }\n            return this;\n        };\n\n        /**\n        * EventEmitters print a warning when an event has greater than this specified\n        * number of listeners.\n        */\n        AbstractEventEmitter.prototype.setMaxListeners = function (n) {\n            this.maxListeners = n;\n        };\n\n        /**\n        * Returns the listeners for the given event.\n        */\n        AbstractEventEmitter.prototype.listeners = function (event) {\n            if (typeof (this._listeners[event]) === 'undefined') {\n                this._listeners[event] = [];\n            }\n\n            // Return a *copy* of our internal structure.\n            return this._listeners[event].slice(0);\n        };\n\n        /**\n        * Emits the specified event to all listeners of the particular event.\n        */\n        AbstractEventEmitter.prototype.emit = function (event) {\n            var args = [];\n            for (var _i = 0; _i < (arguments.length - 1); _i++) {\n                args[_i] = arguments[_i + 1];\n            }\n            var listeners = this._listeners[event], rv = false;\n            if (typeof (listeners) !== 'undefined') {\n                var i;\n                for (i = 0; i < listeners.length; i++) {\n                    rv = true;\n                    listeners[i].apply(this, args);\n                }\n            }\n            return rv;\n        };\n        return AbstractEventEmitter;\n    })();\n    exports.AbstractEventEmitter = AbstractEventEmitter;\n\n    /**\n    * Provides an abstract implementation of the WritableStream and ReadableStream\n    * interfaces.\n    * @todo: Check readable/writable status.\n    */\n    var AbstractDuplexStream = (function (_super) {\n        __extends(AbstractDuplexStream, _super);\n        /**\n        * Abstract stream implementation that can be configured to be readable and/or\n        * writable.\n        */\n        function AbstractDuplexStream(writable, readable) {\n            _super.call(this);\n            this.writable = writable;\n            this.readable = readable;\n            /**\n            * How should the data output be encoded? 'null' means 'Buffer'.\n            */\n            this.encoding = null;\n            /**\n            * Is this stream currently flowing (resumed) or non-flowing (paused)?\n            */\n            this.flowing = false;\n            /**\n            * Event buffer. Simply queues up all write requests.\n            */\n            this.buffer = [];\n            /**\n            * Once set, the stream is closed. Emitted once 'buffer' is empty.\n            */\n            this.endEvent = null;\n            /**\n            * Has the stream ended?\n            */\n            this.ended = false;\n            /**\n            * The last time we checked, was the buffer empty?\n            * We emit 'readable' events when this transitions from 'true' -> 'false'.\n            */\n            this.drained = true;\n        }\n        /**\n        * Adds a listener for the particular event.\n        * Implemented here so that we can capture data EventListeners, which trigger\n        * us to 'resume'.\n        */\n        AbstractDuplexStream.prototype.addListener = function (event, listener) {\n            var rv = _super.prototype.addListener.call(this, event, listener), _this = this;\n            if (event === 'data' && !this.flowing) {\n                this.resume();\n            } else if (event === 'readable' && this.buffer.length > 0) {\n                setTimeout(function () {\n                    _this.emit('readable');\n                }, 0);\n            }\n            return rv;\n        };\n\n        /**\n        * Helper function for 'write' and 'end' functions.\n        */\n        AbstractDuplexStream.prototype._processArgs = function (data, arg2, arg3) {\n            if (typeof (arg2) === 'string') {\n                // data, encoding, cb?\n                return new BufferedEvent(data, arg2, arg3);\n            } else {\n                // data, cb?\n                return new BufferedEvent(data, null, arg2);\n            }\n        };\n\n        /**\n        * If flowing, this will process pending events.\n        */\n        AbstractDuplexStream.prototype._processEvents = function () {\n            var drained = this.buffer.length === 0;\n            if (this.drained !== drained) {\n                if (this.drained) {\n                    // Went from drained to not drained. New stuff is available.\n                    // @todo: Is this event relevant in flowing mode?\n                    this.emit('readable');\n                }\n            }\n\n            if (this.flowing && this.buffer.length !== 0) {\n                this.emit('data', this.read());\n            }\n\n            // Are we drained? Check.\n            this.drained = this.buffer.length === 0;\n        };\n\n        /**\n        * Emits the given buffered event.\n        */\n        AbstractDuplexStream.prototype.emitEvent = function (type, event) {\n            this.emit(type, event.getData(this.encoding));\n            if (event.cb) {\n                event.cb();\n            }\n        };\n\n        AbstractDuplexStream.prototype.write = function (data, arg2, arg3) {\n            if (this.ended) {\n                throw new ApiError(0 /* EPERM */, 'Cannot write to an ended stream.');\n            }\n            var event = this._processArgs(data, arg2, arg3);\n            this._push(event);\n            return this.flowing;\n        };\n\n        AbstractDuplexStream.prototype.end = function (data, arg2, arg3) {\n            if (this.ended) {\n                throw new ApiError(0 /* EPERM */, 'Stream is already closed.');\n            }\n            var event = this._processArgs(data, arg2, arg3);\n            this.ended = true;\n            this.endEvent = event;\n            this._processEvents();\n        };\n\n        /**** Readable Interface ****/\n        /**\n        * Read a given number of bytes from the buffer. Should only be called in\n        * non-flowing mode.\n        * If we do not have `size` bytes available, return null.\n        */\n        AbstractDuplexStream.prototype.read = function (size) {\n            var events = [], eventsCbs = [], lastCb, eventsSize = 0, event, buff, trueSize, i = 0, sizeUnspecified = typeof (size) !== 'number';\n\n            // I do this so I do not need to specialize the loop below.\n            if (sizeUnspecified)\n                size = 4294967295;\n\n            for (i = 0; i < this.buffer.length && eventsSize < size; i++) {\n                event = this.buffer[i];\n                events.push(event.getData());\n                if (event.cb) {\n                    eventsCbs.push(event.cb);\n                }\n                eventsSize += event.size;\n                lastCb = event.cb;\n            }\n\n            if (!sizeUnspecified && eventsSize < size) {\n                // For some reason, the Node stream API specifies that we either return\n                // 'size' bytes of data, or nothing at all.\n                return null;\n            }\n\n            // Remove all of the events we are processing from the buffer.\n            this.buffer = this.buffer.slice(events.length);\n\n            // The 'true size' of the final event we're going to send out.\n            trueSize = eventsSize > size ? size : eventsSize;\n\n            // Concat at all of the events into one buffer.\n            buff = Buffer.concat(events);\n            if (eventsSize > size) {\n                // If last event had a cb, ignore it -- we trigger it when that *entire*\n                // write finishes.\n                if (lastCb)\n                    eventsCbs.pop();\n\n                // Make a new event for the remaining data.\n                this._push(new BufferedEvent(buff.slice(size), null, lastCb));\n            }\n\n            // Schedule the relevant cbs to fire *after* we've returned these values.\n            if (eventsCbs.length > 0) {\n                setTimeout(function () {\n                    var i;\n                    for (i = 0; i < eventsCbs.length; i++) {\n                        eventsCbs[i]();\n                    }\n                }, 0);\n            }\n\n            // If we're at the end of the buffer and an endEvent is specified, schedule\n            // the event to fire.\n            if (this.ended && this.buffer.length === 0 && this.endEvent !== null) {\n                var endEvent = this.endEvent, _this = this;\n\n                // Erase it so we don't accidentally trigger it again.\n                this.endEvent = null;\n                setTimeout(function () {\n                    _this.emitEvent('end', endEvent);\n                }, 0);\n            }\n\n            // Return in correct encoding.\n            if (events.length === 0) {\n                // Buffer was empty. We're supposed to return 'null', as opposed to an\n                // empty buffer or string.\n                // [BFS] Emit a '_read' event to signal that maybe the write-end of this\n                //       should push some data into the pipe.\n                this.emit('_read');\n                return null;\n            } else if (this.encoding === null) {\n                return buff.slice(0, trueSize);\n            } else {\n                return buff.toString(this.encoding, 0, trueSize);\n            }\n        };\n\n        /**\n        * Set the encoding for the 'data' event.\n        */\n        AbstractDuplexStream.prototype.setEncoding = function (encoding) {\n            this.encoding = encoding;\n        };\n\n        /**\n        * Pause the stream.\n        */\n        AbstractDuplexStream.prototype.pause = function () {\n            this.flowing = false;\n        };\n\n        /**\n        * Resume the stream.\n        */\n        AbstractDuplexStream.prototype.resume = function () {\n            this.flowing = true;\n\n            // Process any buffered writes.\n            this._processEvents();\n        };\n\n        /**\n        * Pipe a readable stream into a writable stream. Currently unimplemented.\n        */\n        AbstractDuplexStream.prototype.pipe = function (destination, options) {\n            throw new ApiError(0 /* EPERM */, \"Unimplemented.\");\n        };\n        AbstractDuplexStream.prototype.unpipe = function (destination) {\n        };\n\n        AbstractDuplexStream.prototype.unshift = function (chunk) {\n            if (this.ended) {\n                throw new ApiError(0 /* EPERM */, \"Stream has ended.\");\n            }\n            this.buffer.unshift(new BufferedEvent(chunk, this.encoding));\n            this._processEvents();\n        };\n\n        /**\n        * 'Push' the given piece of data to the back of the buffer.\n        * Returns true if the event was sent out, false if buffered.\n        */\n        AbstractDuplexStream.prototype._push = function (event) {\n            this.buffer.push(event);\n            this._processEvents();\n        };\n\n        /**\n        * Enables backwards-compatibility with older versions of Node and their\n        * stream interface. Unimplemented.\n        */\n        AbstractDuplexStream.prototype.wrap = function (stream) {\n            throw new ApiError(0 /* EPERM */, \"Unimplemented.\");\n        };\n        return AbstractDuplexStream;\n    })(AbstractEventEmitter);\n    exports.AbstractDuplexStream = AbstractDuplexStream;\n});\n//# sourceMappingURL=node_eventemitter.js.map\n;\n","define('core/file_flag',[\"require\", \"exports\", './api_error'], function(require, exports, api_error) {\n    /**\n    * @class\n    */\n    (function (ActionType) {\n        // Indicates that the code should not do anything.\n        ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\n\n        // Indicates that the code should throw an exception.\n        ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\n\n        // Indicates that the code should truncate the file, but only if it is a file.\n        ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\n\n        // Indicates that the code should create the file.\n        ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\n    })(exports.ActionType || (exports.ActionType = {}));\n    var ActionType = exports.ActionType;\n\n    /**\n    * Represents one of the following file flags. A convenience object.\n    *\n    * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\n    * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\n    * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\n    * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\n    * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n    * * `'wx'` - Like 'w' but opens the file in exclusive mode.\n    * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n    * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\n    * * `'a'` - Open file for appending. The file is created if it does not exist.\n    * * `'ax'` - Like 'a' but opens the file in exclusive mode.\n    * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\n    * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\n    *\n    * Exclusive mode ensures that the file path is newly created.\n    * @class\n    */\n    var FileFlag = (function () {\n        /**\n        * This should never be called directly.\n        * @param [String] modeStr The string representing the mode\n        * @throw [BrowserFS.ApiError] when the mode string is invalid\n        */\n        function FileFlag(flagStr) {\n            this.flagStr = flagStr;\n            if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\n                throw new api_error.ApiError(9 /* EINVAL */, \"Invalid flag: \" + flagStr);\n            }\n        }\n        /**\n        * Get an object representing the given file mode.\n        * @param [String] modeStr The string representing the mode\n        * @return [BrowserFS.FileMode] The FileMode object representing the mode\n        * @throw [BrowserFS.ApiError] when the mode string is invalid\n        */\n        FileFlag.getFileFlag = function (flagStr) {\n            // Check cache first.\n            if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\n                return FileFlag.flagCache[flagStr];\n            }\n            return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\n        };\n\n        /**\n        * Returns true if the file is readable.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isReadable = function () {\n            return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\n        };\n\n        /**\n        * Returns true if the file is writeable.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isWriteable = function () {\n            return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\n        };\n\n        /**\n        * Returns true if the file mode should truncate.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isTruncating = function () {\n            return this.flagStr.indexOf('w') !== -1;\n        };\n\n        /**\n        * Returns true if the file is appendable.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isAppendable = function () {\n            return this.flagStr.indexOf('a') !== -1;\n        };\n\n        /**\n        * Returns true if the file is open in synchronous mode.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isSynchronous = function () {\n            return this.flagStr.indexOf('s') !== -1;\n        };\n\n        /**\n        * Returns true if the file is open in exclusive mode.\n        * @return [Boolean]\n        */\n        FileFlag.prototype.isExclusive = function () {\n            return this.flagStr.indexOf('x') !== -1;\n        };\n\n        /**\n        * Returns one of the static fields on this object that indicates the\n        * appropriate response to the path existing.\n        * @return [Number]\n        */\n        FileFlag.prototype.pathExistsAction = function () {\n            if (this.isExclusive()) {\n                return 1 /* THROW_EXCEPTION */;\n            } else if (this.isTruncating()) {\n                return 2 /* TRUNCATE_FILE */;\n            } else {\n                return 0 /* NOP */;\n            }\n        };\n\n        /**\n        * Returns one of the static fields on this object that indicates the\n        * appropriate response to the path not existing.\n        * @return [Number]\n        */\n        FileFlag.prototype.pathNotExistsAction = function () {\n            if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\n                return 3 /* CREATE_FILE */;\n            } else {\n                return 1 /* THROW_EXCEPTION */;\n            }\n        };\n        FileFlag.flagCache = {};\n\n        FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\n        return FileFlag;\n    })();\n    exports.FileFlag = FileFlag;\n});\n//# sourceMappingURL=file_flag.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/node_process',[\"require\", \"exports\", './node_eventemitter'], function(require, exports, eventemitter) {\n    var path = null;\n\n    var TTY = (function (_super) {\n        __extends(TTY, _super);\n        function TTY() {\n            _super.call(this, true, true);\n            this.isRaw = false;\n            this.columns = 80;\n            this.rows = 120;\n            this.isTTY = true;\n        }\n        /**\n        * Set read mode to 'true' to enable raw mode.\n        */\n        TTY.prototype.setReadMode = function (mode) {\n            if (this.isRaw !== mode) {\n                this.isRaw = mode;\n\n                // [BFS] TTY implementations can use this to change their event emitting\n                //       patterns.\n                this.emit('modeChange');\n            }\n        };\n\n        /**\n        * [BFS] Update the number of columns available on the terminal.\n        */\n        TTY.prototype.changeColumns = function (columns) {\n            if (columns !== this.columns) {\n                this.columns = columns;\n\n                // Resize event.\n                this.emit('resize');\n            }\n        };\n\n        /**\n        * [BFS] Update the number of rows available on the terminal.\n        */\n        TTY.prototype.changeRows = function (rows) {\n            if (rows !== this.rows) {\n                this.rows = rows;\n\n                // Resize event.\n                this.emit('resize');\n            }\n        };\n\n        /**\n        * Returns 'true' if the given object is a TTY.\n        */\n        TTY.isatty = function (fd) {\n            return fd instanceof TTY;\n        };\n        return TTY;\n    })(eventemitter.AbstractDuplexStream);\n    exports.TTY = TTY;\n\n    /**\n    * Partial implementation of Node's `process` module.\n    * We implement the portions that are relevant for the filesystem.\n    * @see http://nodejs.org/api/process.html\n    * @class\n    */\n    var Process = (function () {\n        function Process() {\n            this.startTime = Date.now();\n            this._cwd = '/';\n            /**\n            * Returns what platform you are running on.\n            * @return [String]\n            */\n            this.platform = 'browser';\n            this.argv = [];\n            this.stdout = new TTY();\n            this.stderr = new TTY();\n            this.stdin = new TTY();\n        }\n        /**\n        * Changes the current working directory.\n        *\n        * **Note**: BrowserFS does not validate that the directory actually exists.\n        *\n        * @example Usage example\n        *   console.log('Starting directory: ' + process.cwd());\n        *   process.chdir('/tmp');\n        *   console.log('New directory: ' + process.cwd());\n        * @param [String] dir The directory to change to.\n        */\n        Process.prototype.chdir = function (dir) {\n            // XXX: Circular dependency hack.\n            if (path === null) {\n                path = require('./node_path').path;\n            }\n            this._cwd = path.resolve(dir);\n        };\n\n        /**\n        * Returns the current working directory.\n        * @example Usage example\n        *   console.log('Current directory: ' + process.cwd());\n        * @return [String] The current working directory.\n        */\n        Process.prototype.cwd = function () {\n            return this._cwd;\n        };\n\n        /**\n        * Number of seconds BrowserFS has been running.\n        * @return [Number]\n        */\n        Process.prototype.uptime = function () {\n            return ((Date.now() - this.startTime) / 1000) | 0;\n        };\n        return Process;\n    })();\n    exports.Process = Process;\n\n    // process is a singleton.\n    exports.process = new Process();\n});\n//# sourceMappingURL=node_process.js.map\n;\n","define('core/node_path',[\"require\", \"exports\", './node_process'], function(require, exports, node_process) {\n    var process = node_process.process;\n\n    /**\n    * Emulates Node's `path` module. This module contains utilities for handling and\n    * transforming file paths. **All** of these methods perform only string\n    * transformations. The file system is not consulted to check whether paths are\n    * valid.\n    * @see http://nodejs.org/api/path.html\n    * @class\n    */\n    var path = (function () {\n        function path() {\n        }\n        /**\n        * Normalize a string path, taking care of '..' and '.' parts.\n        *\n        * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n        * @example Usage example\n        *   path.normalize('/foo/bar//baz/asdf/quux/..')\n        *   // returns\n        *   '/foo/bar/baz/asdf'\n        * @param [String] p The path to normalize.\n        * @return [String]\n        */\n        path.normalize = function (p) {\n            // Special case: '' -> '.'\n            if (p === '') {\n                p = '.';\n            }\n\n            // It's very important to know if the path is relative or not, since it\n            // changes how we process .. and reconstruct the split string.\n            var absolute = p.charAt(0) === path.sep;\n\n            // Remove repeated //s\n            p = path._removeDuplicateSeps(p);\n\n            // Try to remove as many '../' as possible, and remove '.' completely.\n            var components = p.split(path.sep);\n            var goodComponents = [];\n            for (var idx = 0; idx < components.length; idx++) {\n                var c = components[idx];\n                if (c === '.') {\n                    continue;\n                } else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\n                    // In the absolute case: Path is relative to root, so we may pop even if\n                    // goodComponents is empty (e.g. /../ => /)\n                    // In the relative case: We're getting rid of a directory that preceded\n                    // it (e.g. /foo/../bar -> /bar)\n                    goodComponents.pop();\n                } else {\n                    goodComponents.push(c);\n                }\n            }\n\n            // Add in '.' when it's a relative path with no other nonempty components.\n            // Possible results: '.' and './' (input: [''] or [])\n            // @todo Can probably simplify this logic.\n            if (!absolute && goodComponents.length < 2) {\n                switch (goodComponents.length) {\n                    case 1:\n                        if (goodComponents[0] === '') {\n                            goodComponents.unshift('.');\n                        }\n                        break;\n                    default:\n                        goodComponents.push('.');\n                }\n            }\n            p = goodComponents.join(path.sep);\n            if (absolute && p.charAt(0) !== path.sep) {\n                p = path.sep + p;\n            }\n            return p;\n        };\n\n        /**\n        * Join all arguments together and normalize the resulting path.\n        *\n        * Arguments must be strings.\n        * @example Usage\n        *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\n        *   // returns\n        *   '/foo/bar/baz/asdf'\n        *\n        *   path.join('foo', {}, 'bar')\n        *   // throws exception\n        *   TypeError: Arguments to path.join must be strings\n        * @param [String,...] paths Each component of the path\n        * @return [String]\n        */\n        path.join = function () {\n            var paths = [];\n            for (var _i = 0; _i < (arguments.length - 0); _i++) {\n                paths[_i] = arguments[_i + 0];\n            }\n            // Required: Prune any non-strings from the path. I also prune empty segments\n            // so we can do a simple join of the array.\n            var processed = [];\n            for (var i = 0; i < paths.length; i++) {\n                var segment = paths[i];\n                if (typeof segment !== 'string') {\n                    throw new TypeError(\"Invalid argument type to path.join: \" + (typeof segment));\n                } else if (segment !== '') {\n                    processed.push(segment);\n                }\n            }\n            return path.normalize(processed.join(path.sep));\n        };\n\n        /**\n        * Resolves to to an absolute path.\n        *\n        * If to isn't already absolute from arguments are prepended in right to left\n        * order, until an absolute path is found. If after using all from paths still\n        * no absolute path is found, the current working directory is used as well.\n        * The resulting path is normalized, and trailing slashes are removed unless\n        * the path gets resolved to the root directory. Non-string arguments are\n        * ignored.\n        *\n        * Another way to think of it is as a sequence of cd commands in a shell.\n        *\n        *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\n        *\n        * Is similar to:\n        *\n        *     cd foo/bar\n        *     cd /tmp/file/\n        *     cd ..\n        *     cd a/../subfile\n        *     pwd\n        *\n        * The difference is that the different paths don't need to exist and may also\n        * be files.\n        * @example Usage example\n        *   path.resolve('/foo/bar', './baz')\n        *   // returns\n        *   '/foo/bar/baz'\n        *\n        *   path.resolve('/foo/bar', '/tmp/file/')\n        *   // returns\n        *   '/tmp/file'\n        *\n        *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\n        *   // if currently in /home/myself/node, it returns\n        *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\n        * @param [String,...] paths\n        * @return [String]\n        */\n        path.resolve = function () {\n            var paths = [];\n            for (var _i = 0; _i < (arguments.length - 0); _i++) {\n                paths[_i] = arguments[_i + 0];\n            }\n            // Monitor for invalid paths, throw out empty paths, and look for the *last*\n            // absolute path that we see.\n            var processed = [];\n            for (var i = 0; i < paths.length; i++) {\n                var p = paths[i];\n                if (typeof p !== 'string') {\n                    throw new TypeError(\"Invalid argument type to path.join: \" + (typeof p));\n                } else if (p !== '') {\n                    // Remove anything that has occurred before this absolute path, as it\n                    // doesn't matter.\n                    if (p.charAt(0) === path.sep) {\n                        processed = [];\n                    }\n                    processed.push(p);\n                }\n            }\n\n            // Special: Remove trailing slash unless it's the root\n            var resolved = path.normalize(processed.join(path.sep));\n            if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === path.sep) {\n                return resolved.substr(0, resolved.length - 1);\n            }\n\n            // Special: If it doesn't start with '/', it's relative and we need to append\n            // the current directory.\n            if (resolved.charAt(0) !== path.sep) {\n                // Remove ./, since we're going to append the current directory.\n                if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === path.sep)) {\n                    resolved = resolved.length === 1 ? '' : resolved.substr(2);\n                }\n\n                // Append the current directory, which *must* be an absolute path.\n                var cwd = process.cwd();\n                if (resolved !== '') {\n                    // cwd will never end in a /... unless it's the root.\n                    resolved = this.normalize(cwd + (cwd !== '/' ? path.sep : '') + resolved);\n                } else {\n                    resolved = cwd;\n                }\n            }\n            return resolved;\n        };\n\n        /**\n        * Solve the relative path from from to to.\n        *\n        * At times we have two absolute paths, and we need to derive the relative path\n        * from one to the other. This is actually the reverse transform of\n        * path.resolve, which means we see that:\n        *\n        *    path.resolve(from, path.relative(from, to)) == path.resolve(to)\n        *\n        * @example Usage example\n        *   path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\n        *   // returns\n        *   '..\\\\..\\\\impl\\\\bbb'\n        *\n        *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n        *   // returns\n        *   '../../impl/bbb'\n        * @param [String] from\n        * @param [String] to\n        * @return [String]\n        */\n        path.relative = function (from, to) {\n            var i;\n\n            // Alright. Let's resolve these two to absolute paths and remove any\n            // weirdness.\n            from = path.resolve(from);\n            to = path.resolve(to);\n            var fromSegs = from.split(path.sep);\n            var toSegs = to.split(path.sep);\n\n            // Remove the first segment on both, as it's '' (both are absolute paths)\n            toSegs.shift();\n            fromSegs.shift();\n\n            // There are two segments to this path:\n            // * Going *up* the directory hierarchy with '..'\n            // * Going *down* the directory hierarchy with foo/baz/bat.\n            var upCount = 0;\n            var downSegs = [];\n\n            for (i = 0; i < fromSegs.length; i++) {\n                var seg = fromSegs[i];\n                if (seg === toSegs[i]) {\n                    continue;\n                }\n\n                // The rest of 'from', including the current element, indicates how many\n                // directories we need to go up.\n                upCount = fromSegs.length - i;\n                break;\n            }\n\n            // The rest of 'to' indicates where we need to change to. We place this\n            // outside of the loop, as toSegs.length may be greater than fromSegs.length.\n            downSegs = toSegs.slice(i);\n\n            // Special case: If 'from' is '/'\n            if (fromSegs.length === 1 && fromSegs[0] === '') {\n                upCount = 0;\n            }\n\n            // upCount can't be greater than the number of fromSegs\n            // (cd .. from / is still /)\n            if (upCount > fromSegs.length) {\n                upCount = fromSegs.length;\n            }\n\n            // Create the final string!\n            var rv = '';\n            for (i = 0; i < upCount; i++) {\n                rv += '../';\n            }\n            rv += downSegs.join(path.sep);\n\n            // Special case: Remove trailing '/'. Happens if it's all up and no down.\n            if (rv.length > 1 && rv.charAt(rv.length - 1) === path.sep) {\n                rv = rv.substr(0, rv.length - 1);\n            }\n            return rv;\n        };\n\n        /**\n        * Return the directory name of a path. Similar to the Unix `dirname` command.\n        *\n        * Note that BrowserFS does not validate if the path is actually a valid\n        * directory.\n        * @example Usage example\n        *   path.dirname('/foo/bar/baz/asdf/quux')\n        *   // returns\n        *   '/foo/bar/baz/asdf'\n        * @param [String] p The path to get the directory name of.\n        * @return [String]\n        */\n        path.dirname = function (p) {\n            // We get rid of //, but we don't modify anything else (e.g. any extraneous .\n            // and ../ are kept intact)\n            p = path._removeDuplicateSeps(p);\n            var absolute = p.charAt(0) === path.sep;\n            var sections = p.split(path.sep);\n\n            // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\n            if (sections.pop() === '' && sections.length > 0) {\n                sections.pop();\n            }\n            if (sections.length > 1) {\n                return sections.join(path.sep);\n            } else if (absolute) {\n                return path.sep;\n            } else {\n                return '.';\n            }\n        };\n\n        /**\n        * Return the last portion of a path. Similar to the Unix basename command.\n        * @example Usage example\n        *   path.basename('/foo/bar/baz/asdf/quux.html')\n        *   // returns\n        *   'quux.html'\n        *\n        *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\n        *   // returns\n        *   'quux'\n        * @param [String] p\n        * @param [String?] ext\n        * @return [String]\n        */\n        path.basename = function (p, ext) {\n            if (typeof ext === \"undefined\") { ext = \"\"; }\n            // Special case: Normalize will modify this to '.'\n            if (p === '') {\n                return p;\n            }\n\n            // Normalize the string first to remove any weirdness.\n            p = path.normalize(p);\n\n            // Get the last part of the string.\n            var sections = p.split(path.sep);\n            var lastPart = sections[sections.length - 1];\n\n            // Special case: If it's empty, then we have a string like so: foo/\n            // Meaning, 'foo' is guaranteed to be a directory.\n            if (lastPart === '' && sections.length > 1) {\n                return sections[sections.length - 2];\n            }\n\n            // Remove the extension, if need be.\n            if (ext.length > 0) {\n                var lastPartExt = lastPart.substr(lastPart.length - ext.length);\n                if (lastPartExt === ext) {\n                    return lastPart.substr(0, lastPart.length - ext.length);\n                }\n            }\n            return lastPart;\n        };\n\n        /**\n        * Return the extension of the path, from the last '.' to end of string in the\n        * last portion of the path. If there is no '.' in the last portion of the path\n        * or the first character of it is '.', then it returns an empty string.\n        * @example Usage example\n        *   path.extname('index.html')\n        *   // returns\n        *   '.html'\n        *\n        *   path.extname('index.')\n        *   // returns\n        *   '.'\n        *\n        *   path.extname('index')\n        *   // returns\n        *   ''\n        * @param [String] p\n        * @return [String]\n        */\n        path.extname = function (p) {\n            p = path.normalize(p);\n            var sections = p.split(path.sep);\n            p = sections.pop();\n\n            // Special case: foo/file.ext/ should return '.ext'\n            if (p === '' && sections.length > 0) {\n                p = sections.pop();\n            }\n            if (p === '..') {\n                return '';\n            }\n            var i = p.lastIndexOf('.');\n            if (i === -1 || i === 0) {\n                return '';\n            }\n            return p.substr(i);\n        };\n\n        /**\n        * Checks if the given path is an absolute path.\n        *\n        * Despite not being documented, this is a tested part of Node's path API.\n        * @param [String] p\n        * @return [Boolean] True if the path appears to be an absolute path.\n        */\n        path.isAbsolute = function (p) {\n            return p.length > 0 && p.charAt(0) === path.sep;\n        };\n\n        /**\n        * Unknown. Undocumented.\n        */\n        path._makeLong = function (p) {\n            return p;\n        };\n\n        path._removeDuplicateSeps = function (p) {\n            p = p.replace(this._replaceRegex, this.sep);\n            return p;\n        };\n        path.sep = '/';\n\n        path._replaceRegex = new RegExp(\"//+\", 'g');\n\n        path.delimiter = ':';\n        return path;\n    })();\n    exports.path = path;\n});\n//# sourceMappingURL=node_path.js.map\n;\n","define('core/node_fs',[\"require\", \"exports\", './api_error', './file_flag', './buffer', './node_path'], function(require, exports, api_error, file_flag, buffer, node_path) {\n    var ApiError = api_error.ApiError;\n    var ErrorCode = api_error.ErrorCode;\n    var FileFlag = file_flag.FileFlag;\n    var Buffer = buffer.Buffer;\n    var path = node_path.path;\n\n    /**\n    * Wraps a callback with a setImmediate call.\n    * @param [Function] cb The callback to wrap.\n    * @param [Number] numArgs The number of arguments that the callback takes.\n    * @return [Function] The wrapped callback.\n    */\n    function wrapCb(cb, numArgs) {\n        if (typeof cb !== 'function') {\n            throw new ApiError(9 /* EINVAL */, 'Callback must be a function.');\n        }\n\n        // @todo This is used for unit testing. Maybe we should inject this logic\n        //       dynamically rather than bundle it in 'production' code.\n        if (typeof __numWaiting === 'undefined') {\n            __numWaiting = 0;\n        }\n        __numWaiting++;\n\n        switch (numArgs) {\n            case 1:\n                return function (arg1) {\n                    setImmediate(function () {\n                        __numWaiting--;\n                        return cb(arg1);\n                    });\n                };\n            case 2:\n                return function (arg1, arg2) {\n                    setImmediate(function () {\n                        __numWaiting--;\n                        return cb(arg1, arg2);\n                    });\n                };\n            case 3:\n                return function (arg1, arg2, arg3) {\n                    setImmediate(function () {\n                        __numWaiting--;\n                        return cb(arg1, arg2, arg3);\n                    });\n                };\n            default:\n                throw new Error('Invalid invocation of wrapCb.');\n        }\n    }\n\n    /**\n    * Checks if the fd is valid.\n    * @param [BrowserFS.File] fd A file descriptor (in BrowserFS, it's a File object)\n    * @return [Boolean, BrowserFS.ApiError] Returns `true` if the FD is OK,\n    *   otherwise returns an ApiError.\n    */\n    function checkFd(fd) {\n        if (typeof fd['write'] !== 'function') {\n            throw new ApiError(3 /* EBADF */, 'Invalid file descriptor.');\n        }\n    }\n\n    function normalizeMode(mode, def) {\n        switch (typeof mode) {\n            case 'number':\n                // (path, flag, mode, cb?)\n                return mode;\n            case 'string':\n                // (path, flag, modeString, cb?)\n                var trueMode = parseInt(mode, 8);\n                if (trueMode !== NaN) {\n                    return trueMode;\n                }\n\n            default:\n                return def;\n        }\n    }\n\n    function normalizePath(p) {\n        // Node doesn't allow null characters in paths.\n        if (p.indexOf('\\u0000') >= 0) {\n            throw new ApiError(9 /* EINVAL */, 'Path must be a string without null bytes.');\n        } else if (p === '') {\n            throw new ApiError(9 /* EINVAL */, 'Path must not be empty.');\n        }\n        return path.resolve(p);\n    }\n\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\n        switch (typeof options) {\n            case 'object':\n                return {\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\n                    mode: normalizeMode(options['mode'], defMode)\n                };\n            case 'string':\n                return {\n                    encoding: options,\n                    flag: defFlag,\n                    mode: defMode\n                };\n            default:\n                return {\n                    encoding: defEnc,\n                    flag: defFlag,\n                    mode: defMode\n                };\n        }\n    }\n\n    // The default callback is a NOP.\n    function nopCb() {\n    }\n    ;\n\n    /**\n    * The node frontend to all filesystems.\n    * This layer handles:\n    *\n    * * Sanity checking inputs.\n    * * Normalizing paths.\n    * * Resetting stack depth for asynchronous operations which may not go through\n    *   the browser by wrapping all input callbacks using `setImmediate`.\n    * * Performing the requested operation through the filesystem or the file\n    *   descriptor, as appropriate.\n    * * Handling optional arguments and setting default arguments.\n    * @see http://nodejs.org/api/fs.html\n    * @class\n    */\n    var fs = (function () {\n        function fs() {\n        }\n        fs._initialize = function (rootFS) {\n            if (!rootFS.constructor.isAvailable()) {\n                throw new ApiError(9 /* EINVAL */, 'Tried to instantiate BrowserFS with an unavailable file system.');\n            }\n            return fs.root = rootFS;\n        };\n\n        fs._toUnixTimestamp = function (time) {\n            if (typeof time === 'number') {\n                return time;\n            } else if (time instanceof Date) {\n                return time.getTime() / 1000;\n            }\n            throw new Error(\"Cannot parse time: \" + time);\n        };\n\n        /**\n        * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\n        * @return [BrowserFS.FileSystem | null] Returns null if the file system has\n        *   not been initialized.\n        */\n        fs.getRootFS = function () {\n            if (fs.root) {\n                return fs.root;\n            } else {\n                return null;\n            }\n        };\n\n        // FILE OR DIRECTORY METHODS\n        /**\n        * Asynchronous rename. No arguments other than a possible exception are given\n        * to the completion callback.\n        * @param [String] oldPath\n        * @param [String] newPath\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.rename = function (oldPath, newPath, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                fs.root.rename(normalizePath(oldPath), normalizePath(newPath), newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous rename.\n        * @param [String] oldPath\n        * @param [String] newPath\n        */\n        fs.renameSync = function (oldPath, newPath) {\n            fs.root.renameSync(normalizePath(oldPath), normalizePath(newPath));\n        };\n\n        /**\n        * Test whether or not the given path exists by checking with the file system.\n        * Then call the callback argument with either true or false.\n        * @example Sample invocation\n        *   fs.exists('/etc/passwd', function (exists) {\n        *     util.debug(exists ? \"it's there\" : \"no passwd!\");\n        *   });\n        * @param [String] path\n        * @param [Function(Boolean)] callback\n        */\n        fs.exists = function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                return fs.root.exists(normalizePath(path), newCb);\n            } catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return newCb(false);\n            }\n        };\n\n        /**\n        * Test whether or not the given path exists by checking with the file system.\n        * @param [String] path\n        * @return [boolean]\n        */\n        fs.existsSync = function (path) {\n            try  {\n                return fs.root.existsSync(normalizePath(path));\n            } catch (e) {\n                // Doesn't return an error. If something bad happens, we assume it just\n                // doesn't exist.\n                return false;\n            }\n        };\n\n        /**\n        * Asynchronous `stat`.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] callback\n        */\n        fs.stat = function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                return fs.root.stat(normalizePath(path), false, newCb);\n            } catch (e) {\n                return newCb(e, null);\n            }\n        };\n\n        /**\n        * Synchronous `stat`.\n        * @param [String] path\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        fs.statSync = function (path) {\n            return fs.root.statSync(normalizePath(path), false);\n        };\n\n        /**\n        * Asynchronous `lstat`.\n        * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n        * then the link itself is stat-ed, not the file that it refers to.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] callback\n        */\n        fs.lstat = function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                return fs.root.stat(normalizePath(path), true, newCb);\n            } catch (e) {\n                return newCb(e, null);\n            }\n        };\n\n        /**\n        * Synchronous `lstat`.\n        * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n        * then the link itself is stat-ed, not the file that it refers to.\n        * @param [String] path\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        fs.lstatSync = function (path) {\n            return fs.root.statSync(normalizePath(path), true);\n        };\n\n        fs.truncate = function (path, arg2, cb) {\n            if (typeof arg2 === \"undefined\") { arg2 = 0; }\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var len = 0;\n            if (typeof arg2 === 'function') {\n                cb = arg2;\n            } else if (typeof arg2 === 'number') {\n                len = arg2;\n            }\n\n            var newCb = wrapCb(cb, 1);\n            try  {\n                if (len < 0) {\n                    throw new ApiError(9 /* EINVAL */);\n                }\n                return fs.root.truncate(normalizePath(path), len, newCb);\n            } catch (e) {\n                return newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `truncate`.\n        * @param [String] path\n        * @param [Number] len\n        */\n        fs.truncateSync = function (path, len) {\n            if (typeof len === \"undefined\") { len = 0; }\n            if (len < 0) {\n                throw new ApiError(9 /* EINVAL */);\n            }\n            return fs.root.truncateSync(normalizePath(path), len);\n        };\n\n        /**\n        * Asynchronous `unlink`.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.unlink = function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                return fs.root.unlink(normalizePath(path), newCb);\n            } catch (e) {\n                return newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `unlink`.\n        * @param [String] path\n        */\n        fs.unlinkSync = function (path) {\n            return fs.root.unlinkSync(normalizePath(path));\n        };\n\n        fs.open = function (path, flag, arg2, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var mode = normalizeMode(arg2, 0x1a4);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            var newCb = wrapCb(cb, 2);\n            try  {\n                return fs.root.open(normalizePath(path), FileFlag.getFileFlag(flag), mode, newCb);\n            } catch (e) {\n                return newCb(e, null);\n            }\n        };\n\n        fs.openSync = function (path, flag, mode) {\n            if (typeof mode === \"undefined\") { mode = 0x1a4; }\n            return fs.root.openSync(normalizePath(path), FileFlag.getFileFlag(flag), mode);\n        };\n\n        fs.readFile = function (filename, arg2, cb) {\n            if (typeof arg2 === \"undefined\") { arg2 = {}; }\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var options = normalizeOptions(arg2, null, 'r', null);\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            var newCb = wrapCb(cb, 2);\n            try  {\n                var flag = FileFlag.getFileFlag(options['flag']);\n                if (!flag.isReadable()) {\n                    return newCb(new ApiError(9 /* EINVAL */, 'Flag passed to readFile must allow for reading.'));\n                }\n                return fs.root.readFile(normalizePath(filename), options.encoding, flag, newCb);\n            } catch (e) {\n                return newCb(e, null);\n            }\n        };\n\n        fs.readFileSync = function (filename, arg2) {\n            if (typeof arg2 === \"undefined\") { arg2 = {}; }\n            var options = normalizeOptions(arg2, null, 'r', null);\n            var flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isReadable()) {\n                throw new ApiError(9 /* EINVAL */, 'Flag passed to readFile must allow for reading.');\n            }\n            return fs.root.readFileSync(normalizePath(filename), options.encoding, flag);\n        };\n\n        fs.writeFile = function (filename, data, arg3, cb) {\n            if (typeof arg3 === \"undefined\") { arg3 = {}; }\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            var newCb = wrapCb(cb, 1);\n            try  {\n                var flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isWriteable()) {\n                    return newCb(new ApiError(9 /* EINVAL */, 'Flag passed to writeFile must allow for writing.'));\n                }\n                return fs.root.writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            } catch (e) {\n                return newCb(e);\n            }\n        };\n\n        fs.writeFileSync = function (filename, data, arg3) {\n            var options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n            var flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isWriteable()) {\n                throw new ApiError(9 /* EINVAL */, 'Flag passed to writeFile must allow for writing.');\n            }\n            return fs.root.writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        };\n\n        fs.appendFile = function (filename, data, arg3, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            var newCb = wrapCb(cb, 1);\n            try  {\n                var flag = FileFlag.getFileFlag(options.flag);\n                if (!flag.isAppendable()) {\n                    return newCb(new ApiError(9 /* EINVAL */, 'Flag passed to appendFile must allow for appending.'));\n                }\n                fs.root.appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.appendFileSync = function (filename, data, arg3) {\n            var options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n            var flag = FileFlag.getFileFlag(options.flag);\n            if (!flag.isAppendable()) {\n                throw new ApiError(9 /* EINVAL */, 'Flag passed to appendFile must allow for appending.');\n            }\n            return fs.root.appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\n        };\n\n        // FILE DESCRIPTOR METHODS\n        /**\n        * Asynchronous `fstat`.\n        * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n        * specified by the file descriptor `fd`.\n        * @param [BrowserFS.File] fd\n        * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] callback\n        */\n        fs.fstat = function (fd, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                checkFd(fd);\n                fd.stat(newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `fstat`.\n        * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n        * specified by the file descriptor `fd`.\n        * @param [BrowserFS.File] fd\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        fs.fstatSync = function (fd) {\n            checkFd(fd);\n            return fd.statSync();\n        };\n\n        /**\n        * Asynchronous close.\n        * @param [BrowserFS.File] fd\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.close = function (fd, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                fd.close(newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous close.\n        * @param [BrowserFS.File] fd\n        */\n        fs.closeSync = function (fd) {\n            checkFd(fd);\n            return fd.closeSync();\n        };\n\n        fs.ftruncate = function (fd, arg2, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var length = typeof arg2 === 'number' ? arg2 : 0;\n            cb = typeof arg2 === 'function' ? arg2 : cb;\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                if (length < 0) {\n                    throw new ApiError(9 /* EINVAL */);\n                }\n                fd.truncate(length, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous ftruncate.\n        * @param [BrowserFS.File] fd\n        * @param [Number] len\n        */\n        fs.ftruncateSync = function (fd, len) {\n            if (typeof len === \"undefined\") { len = 0; }\n            checkFd(fd);\n            return fd.truncateSync(len);\n        };\n\n        /**\n        * Asynchronous fsync.\n        * @param [BrowserFS.File] fd\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.fsync = function (fd, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                fd.sync(newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous fsync.\n        * @param [BrowserFS.File] fd\n        */\n        fs.fsyncSync = function (fd) {\n            checkFd(fd);\n            return fd.syncSync();\n        };\n\n        /**\n        * Asynchronous fdatasync.\n        * @param [BrowserFS.File] fd\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.fdatasync = function (fd, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                fd.datasync(newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous fdatasync.\n        * @param [BrowserFS.File] fd\n        */\n        fs.fdatasyncSync = function (fd) {\n            checkFd(fd);\n            fd.datasyncSync();\n        };\n\n        fs.write = function (fd, arg2, arg3, arg4, arg5, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var buffer, offset, length, position = null;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\n                var encoding = 'utf8';\n                switch (typeof arg3) {\n                    case 'function':\n                        // (fd, string, cb)\n                        cb = arg3;\n                        break;\n                    case 'number':\n                        // (fd, string, position, encoding?, cb?)\n                        position = arg3;\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\n                        break;\n                    default:\n                        // ...try to find the callback and get out of here!\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\n                        return cb(new ApiError(9 /* EINVAL */, 'Invalid arguments.'));\n                }\n                buffer = new Buffer(arg2, encoding);\n                offset = 0;\n                length = buffer.length;\n            } else {\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n            }\n\n            var newCb = wrapCb(cb, 3);\n            try  {\n                checkFd(fd);\n                if (position == null) {\n                    position = fd.getPos();\n                }\n                fd.write(buffer, offset, length, position, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.writeSync = function (fd, arg2, arg3, arg4, arg5) {\n            var buffer, offset = 0, length, position;\n            if (typeof arg2 === 'string') {\n                // Signature 1: (fd, string, [position?, [encoding?]])\n                position = typeof arg3 === 'number' ? arg3 : null;\n                var encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\n                offset = 0;\n                buffer = new Buffer(arg2, encoding);\n                length = buffer.length;\n            } else {\n                // Signature 2: (fd, buffer, offset, length, position?)\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = typeof arg5 === 'number' ? arg5 : null;\n            }\n\n            checkFd(fd);\n            if (position == null) {\n                position = fd.getPos();\n            }\n            return fd.writeSync(buffer, offset, length, position);\n        };\n\n        fs.read = function (fd, arg2, arg3, arg4, arg5, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var position, offset, length, buffer, newCb;\n            if (typeof arg2 === 'number') {\n                // legacy interface\n                // (fd, length, position, encoding, callback)\n                length = arg2;\n                position = arg3;\n                var encoding = arg4;\n                cb = typeof arg5 === 'function' ? arg5 : cb;\n                offset = 0;\n                buffer = new Buffer(length);\n\n                // XXX: Inefficient.\n                // Wrap the cb so we shelter upper layers of the API from these\n                // shenanigans.\n                newCb = wrapCb((function (err, bytesRead, buf) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    cb(err, buf.toString(encoding), bytesRead);\n                }), 3);\n            } else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n                newCb = wrapCb(cb, 3);\n            }\n\n            try  {\n                checkFd(fd);\n                if (position == null) {\n                    position = fd.getPos();\n                }\n                fd.read(buffer, offset, length, position, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.readSync = function (fd, arg2, arg3, arg4, arg5) {\n            var shenanigans = false;\n            var buffer, offset, length, position;\n            if (typeof arg2 === 'number') {\n                length = arg2;\n                position = arg3;\n                var encoding = arg4;\n                offset = 0;\n                buffer = new Buffer(length);\n                shenanigans = true;\n            } else {\n                buffer = arg2;\n                offset = arg3;\n                length = arg4;\n                position = arg5;\n            }\n            checkFd(fd);\n            if (position == null) {\n                position = fd.getPos();\n            }\n\n            var rv = fd.readSync(buffer, offset, length, position);\n            if (!shenanigans) {\n                return rv;\n            } else {\n                return [buffer.toString(encoding), rv];\n            }\n        };\n\n        /**\n        * Asynchronous `fchown`.\n        * @param [BrowserFS.File] fd\n        * @param [Number] uid\n        * @param [Number] gid\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.fchown = function (fd, uid, gid, callback) {\n            if (typeof callback === \"undefined\") { callback = nopCb; }\n            var newCb = wrapCb(callback, 1);\n            try  {\n                checkFd(fd);\n                fd.chown(uid, gid, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `fchown`.\n        * @param [BrowserFS.File] fd\n        * @param [Number] uid\n        * @param [Number] gid\n        */\n        fs.fchownSync = function (fd, uid, gid) {\n            checkFd(fd);\n            return fd.chownSync(uid, gid);\n        };\n\n        fs.fchmod = function (fd, mode, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                checkFd(fd);\n                fd.chmod(mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.fchmodSync = function (fd, mode) {\n            mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            checkFd(fd);\n            return fd.chmodSync(mode);\n        };\n\n        fs.futimes = function (fd, atime, mtime, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                checkFd(fd);\n                if (typeof atime === 'number') {\n                    atime = new Date(atime * 1000);\n                }\n                if (typeof mtime === 'number') {\n                    mtime = new Date(mtime * 1000);\n                }\n                fd.utimes(atime, mtime, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.futimesSync = function (fd, atime, mtime) {\n            checkFd(fd);\n            if (typeof atime === 'number') {\n                atime = new Date(atime * 1000);\n            }\n            if (typeof mtime === 'number') {\n                mtime = new Date(mtime * 1000);\n            }\n            return fd.utimesSync(atime, mtime);\n        };\n\n        // DIRECTORY-ONLY METHODS\n        /**\n        * Asynchronous `rmdir`.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.rmdir = function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                fs.root.rmdir(path, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `rmdir`.\n        * @param [String] path\n        */\n        fs.rmdirSync = function (path) {\n            path = normalizePath(path);\n            return fs.root.rmdirSync(path);\n        };\n\n        /**\n        * Asynchronous `mkdir`.\n        * @param [String] path\n        * @param [Number?] mode defaults to `0777`\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.mkdir = function (path, mode, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            if (typeof mode === 'function') {\n                cb = mode;\n                mode = 0x1ff;\n            }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                fs.root.mkdir(path, mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.mkdirSync = function (path, mode) {\n            if (typeof mode === \"undefined\") { mode = 0x1ff; }\n            mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            path = normalizePath(path);\n            return fs.root.mkdirSync(path, mode);\n        };\n\n        /**\n        * Asynchronous `readdir`. Reads the contents of a directory.\n        * The callback gets two arguments `(err, files)` where `files` is an array of\n        * the names of the files in the directory excluding `'.'` and `'..'`.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError, String[])] callback\n        */\n        fs.readdir = function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                path = normalizePath(path);\n                fs.root.readdir(path, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `readdir`. Reads the contents of a directory.\n        * @param [String] path\n        * @return [String[]]\n        */\n        fs.readdirSync = function (path) {\n            path = normalizePath(path);\n            return fs.root.readdirSync(path);\n        };\n\n        // SYMLINK METHODS\n        /**\n        * Asynchronous `link`.\n        * @param [String] srcpath\n        * @param [String] dstpath\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.link = function (srcpath, dstpath, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                fs.root.link(srcpath, dstpath, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `link`.\n        * @param [String] srcpath\n        * @param [String] dstpath\n        */\n        fs.linkSync = function (srcpath, dstpath) {\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return fs.root.linkSync(srcpath, dstpath);\n        };\n\n        fs.symlink = function (srcpath, dstpath, arg3, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var type = typeof arg3 === 'string' ? arg3 : 'file';\n            cb = typeof arg3 === 'function' ? arg3 : cb;\n            var newCb = wrapCb(cb, 1);\n            try  {\n                if (type !== 'file' && type !== 'dir') {\n                    return newCb(new ApiError(9 /* EINVAL */, \"Invalid type: \" + type));\n                }\n                srcpath = normalizePath(srcpath);\n                dstpath = normalizePath(dstpath);\n                fs.root.symlink(srcpath, dstpath, type, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `symlink`.\n        * @param [String] srcpath\n        * @param [String] dstpath\n        * @param [String?] type can be either `'dir'` or `'file'` (default is `'file'`)\n        */\n        fs.symlinkSync = function (srcpath, dstpath, type) {\n            if (type == null) {\n                type = 'file';\n            } else if (type !== 'file' && type !== 'dir') {\n                throw new ApiError(9 /* EINVAL */, \"Invalid type: \" + type);\n            }\n            srcpath = normalizePath(srcpath);\n            dstpath = normalizePath(dstpath);\n            return fs.root.symlinkSync(srcpath, dstpath, type);\n        };\n\n        /**\n        * Asynchronous readlink.\n        * @param [String] path\n        * @param [Function(BrowserFS.ApiError, String)] callback\n        */\n        fs.readlink = function (path, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 2);\n            try  {\n                path = normalizePath(path);\n                fs.root.readlink(path, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous readlink.\n        * @param [String] path\n        * @return [String]\n        */\n        fs.readlinkSync = function (path) {\n            path = normalizePath(path);\n            return fs.root.readlinkSync(path);\n        };\n\n        // PROPERTY OPERATIONS\n        /**\n        * Asynchronous `chown`.\n        * @param [String] path\n        * @param [Number] uid\n        * @param [Number] gid\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.chown = function (path, uid, gid, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                fs.root.chown(path, false, uid, gid, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `chown`.\n        * @param [String] path\n        * @param [Number] uid\n        * @param [Number] gid\n        */\n        fs.chownSync = function (path, uid, gid) {\n            path = normalizePath(path);\n            fs.root.chownSync(path, false, uid, gid);\n        };\n\n        /**\n        * Asynchronous `lchown`.\n        * @param [String] path\n        * @param [Number] uid\n        * @param [Number] gid\n        * @param [Function(BrowserFS.ApiError)] callback\n        */\n        fs.lchown = function (path, uid, gid, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                fs.root.chown(path, true, uid, gid, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `lchown`.\n        * @param [String] path\n        * @param [Number] uid\n        * @param [Number] gid\n        */\n        fs.lchownSync = function (path, uid, gid) {\n            path = normalizePath(path);\n            return fs.root.chownSync(path, true, uid, gid);\n        };\n\n        fs.chmod = function (path, mode, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                path = normalizePath(path);\n                fs.root.chmod(path, false, mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.chmodSync = function (path, mode) {\n            mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            path = normalizePath(path);\n            return fs.root.chmodSync(path, false, mode);\n        };\n\n        fs.lchmod = function (path, mode, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n                path = normalizePath(path);\n                fs.root.chmod(path, true, mode, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.lchmodSync = function (path, mode) {\n            path = normalizePath(path);\n            mode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n            return fs.root.chmodSync(path, true, mode);\n        };\n\n        fs.utimes = function (path, atime, mtime, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var newCb = wrapCb(cb, 1);\n            try  {\n                path = normalizePath(path);\n                if (typeof atime === 'number') {\n                    atime = new Date(atime * 1000);\n                }\n                if (typeof mtime === 'number') {\n                    mtime = new Date(mtime * 1000);\n                }\n                fs.root.utimes(path, atime, mtime, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        fs.utimesSync = function (path, atime, mtime) {\n            path = normalizePath(path);\n            if (typeof atime === 'number') {\n                atime = new Date(atime * 1000);\n            }\n            if (typeof mtime === 'number') {\n                mtime = new Date(mtime * 1000);\n            }\n            return fs.root.utimesSync(path, atime, mtime);\n        };\n\n        fs.realpath = function (path, arg2, cb) {\n            if (typeof cb === \"undefined\") { cb = nopCb; }\n            var cache = typeof arg2 === 'object' ? arg2 : {};\n            cb = typeof arg2 === 'function' ? arg2 : nopCb;\n            var newCb = wrapCb(cb, 2);\n            try  {\n                path = normalizePath(path);\n                fs.root.realpath(path, cache, newCb);\n            } catch (e) {\n                newCb(e);\n            }\n        };\n\n        /**\n        * Synchronous `realpath`.\n        * @param [String] path\n        * @param [Object?] cache An object literal of mapped paths that can be used to\n        *   force a specific path resolution or avoid additional `fs.stat` calls for\n        *   known real paths.\n        * @return [String]\n        */\n        fs.realpathSync = function (path, cache) {\n            if (typeof cache === \"undefined\") { cache = {}; }\n            path = normalizePath(path);\n            return fs.root.realpathSync(path, cache);\n        };\n        fs.root = null;\n        return fs;\n    })();\n    exports.fs = fs;\n});\n//# sourceMappingURL=node_fs.js.map\n;\n","define('generic/emscripten_fs',[\"require\", \"exports\", '../core/browserfs', '../core/node_fs', '../core/buffer', '../core/buffer_core_arraybuffer'], function(require, exports, BrowserFS, node_fs, buffer, buffer_core_arraybuffer) {\n    var Buffer = buffer.Buffer;\n    var BufferCoreArrayBuffer = buffer_core_arraybuffer.BufferCoreArrayBuffer;\n    var fs = node_fs.fs;\n\n    var BFSEmscriptenStreamOps = (function () {\n        function BFSEmscriptenStreamOps(fs) {\n            this.fs = fs;\n        }\n        BFSEmscriptenStreamOps.prototype.open = function (stream) {\n            var path = this.fs.realPath(stream.node);\n            try  {\n                if (FS.isFile(stream.node.mode)) {\n                    stream.nfd = fs.openSync(path, this.fs.flagsToPermissionString(stream.flags));\n                }\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n\n        BFSEmscriptenStreamOps.prototype.close = function (stream) {\n            try  {\n                if (FS.isFile(stream.node.mode) && stream.nfd) {\n                    fs.closeSync(stream.nfd);\n                }\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n\n        BFSEmscriptenStreamOps.prototype.read = function (stream, buffer, offset, length, position) {\n            // Avoid copying overhead by reading directly into buffer.\n            var bcore = new BufferCoreArrayBuffer(buffer.buffer);\n            var nbuffer = new Buffer(bcore, buffer.byteOffset + offset, buffer.byteOffset + offset + length);\n            var res;\n            try  {\n                res = fs.readSync(stream.nfd, nbuffer, 0, length, position);\n            } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n\n            // No copying needed, since we wrote directly into UintArray.\n            return res;\n        };\n\n        BFSEmscriptenStreamOps.prototype.write = function (stream, buffer, offset, length, position) {\n            // Avoid copying overhead; plug the buffer directly into a BufferCore.\n            var bcore = new BufferCoreArrayBuffer(buffer.buffer);\n            var nbuffer = new Buffer(bcore, buffer.byteOffset + offset, buffer.byteOffset + offset + length);\n            var res;\n            try  {\n                res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);\n            } catch (e) {\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n            return res;\n        };\n\n        BFSEmscriptenStreamOps.prototype.llseek = function (stream, offset, whence) {\n            var position = offset;\n            if (whence === 1) {\n                position += stream.position;\n            } else if (whence === 2) {\n                if (FS.isFile(stream.node.mode)) {\n                    try  {\n                        var stat = fs.fstatSync(stream.nfd);\n                        position += stat.size;\n                    } catch (e) {\n                        throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n                    }\n                }\n            }\n\n            if (position < 0) {\n                throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n            }\n\n            stream.position = position;\n            return position;\n        };\n        return BFSEmscriptenStreamOps;\n    })();\n\n    var BFSEmscriptenNodeOps = (function () {\n        function BFSEmscriptenNodeOps(fs) {\n            this.fs = fs;\n        }\n        BFSEmscriptenNodeOps.prototype.getattr = function (node) {\n            var path = this.fs.realPath(node);\n            var stat;\n            try  {\n                stat = fs.lstatSync(path);\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n            return {\n                dev: stat.dev,\n                ino: stat.ino,\n                mode: stat.mode,\n                nlink: stat.nlink,\n                uid: stat.uid,\n                gid: stat.gid,\n                rdev: stat.rdev,\n                size: stat.size,\n                atime: stat.atime,\n                mtime: stat.mtime,\n                ctime: stat.ctime,\n                blksize: stat.blksize,\n                blocks: stat.blocks\n            };\n        };\n\n        BFSEmscriptenNodeOps.prototype.setattr = function (node, attr) {\n            var path = this.fs.realPath(node);\n            try  {\n                if (attr.mode !== undefined) {\n                    fs.chmodSync(path, attr.mode);\n\n                    // update the common node structure mode as well\n                    node.mode = attr.mode;\n                }\n                if (attr.timestamp !== undefined) {\n                    var date = new Date(attr.timestamp);\n                    fs.utimesSync(path, date, date);\n                }\n                if (attr.size !== undefined) {\n                    fs.truncateSync(path, attr.size);\n                }\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n\n        BFSEmscriptenNodeOps.prototype.lookup = function (parent, name) {\n            var path = PATH.join2(this.fs.realPath(parent), name);\n            var mode = this.fs.getMode(path);\n            return this.fs.createNode(parent, name, mode);\n        };\n\n        BFSEmscriptenNodeOps.prototype.mknod = function (parent, name, mode, dev) {\n            var node = this.fs.createNode(parent, name, mode, dev);\n\n            // create the backing node for this in the fs root as well\n            var path = this.fs.realPath(node);\n            try  {\n                if (FS.isDir(node.mode)) {\n                    fs.mkdirSync(path, node.mode);\n                } else {\n                    fs.writeFileSync(path, '', { mode: node.mode });\n                }\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n            return node;\n        };\n\n        BFSEmscriptenNodeOps.prototype.rename = function (oldNode, newDir, newName) {\n            var oldPath = this.fs.realPath(oldNode);\n            var newPath = PATH.join2(this.fs.realPath(newDir), newName);\n            try  {\n                fs.renameSync(oldPath, newPath);\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n\n        BFSEmscriptenNodeOps.prototype.unlink = function (parent, name) {\n            var path = PATH.join2(this.fs.realPath(parent), name);\n            try  {\n                fs.unlinkSync(path);\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n\n        BFSEmscriptenNodeOps.prototype.rmdir = function (parent, name) {\n            var path = PATH.join2(this.fs.realPath(parent), name);\n            try  {\n                fs.rmdirSync(path);\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n\n        BFSEmscriptenNodeOps.prototype.readdir = function (node) {\n            var path = this.fs.realPath(node);\n            try  {\n                return fs.readdirSync(path);\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n\n        BFSEmscriptenNodeOps.prototype.symlink = function (parent, newName, oldPath) {\n            var newPath = PATH.join2(this.fs.realPath(parent), newName);\n            try  {\n                fs.symlinkSync(oldPath, newPath);\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n\n        BFSEmscriptenNodeOps.prototype.readlink = function (node) {\n            var path = this.fs.realPath(node);\n            try  {\n                return fs.readlinkSync(path);\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n        };\n        return BFSEmscriptenNodeOps;\n    })();\n\n    var BFSEmscriptenFS = (function () {\n        function BFSEmscriptenFS() {\n            // This maps the integer permission modes from http://linux.die.net/man/3/open\n            // to node.js-specific file open permission strings at http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback\n            this.flagsToPermissionStringMap = {\n                0: 'r',\n                1: 'r+',\n                2: 'r+',\n                64: 'r',\n                65: 'r+',\n                66: 'r+',\n                129: 'rx+',\n                193: 'rx+',\n                514: 'w+',\n                577: 'w',\n                578: 'w+',\n                705: 'wx',\n                706: 'wx+',\n                1024: 'a',\n                1025: 'a',\n                1026: 'a+',\n                1089: 'a',\n                1090: 'a+',\n                1153: 'ax',\n                1154: 'ax+',\n                1217: 'ax',\n                1218: 'ax+',\n                4096: 'rs',\n                4098: 'rs+'\n            };\n            this.node_ops = new BFSEmscriptenNodeOps(this);\n            this.stream_ops = new BFSEmscriptenStreamOps(this);\n            if (typeof BrowserFS === 'undefined') {\n                throw new Error(\"BrowserFS is not loaded. Please load it before this library.\");\n            }\n        }\n        BFSEmscriptenFS.prototype.mount = function (mount) {\n            return this.createNode(null, '/', this.getMode(mount.opts.root), 0);\n        };\n\n        BFSEmscriptenFS.prototype.createNode = function (parent, name, mode, dev) {\n            if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\n                throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\n            }\n            var node = FS.createNode(parent, name, mode);\n            node.node_ops = this.node_ops;\n            node.stream_ops = this.stream_ops;\n            return node;\n        };\n\n        BFSEmscriptenFS.prototype.getMode = function (path) {\n            var stat;\n            try  {\n                stat = fs.lstatSync(path);\n            } catch (e) {\n                if (!e.code)\n                    throw e;\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\n            }\n            return stat.mode;\n        };\n\n        BFSEmscriptenFS.prototype.realPath = function (node) {\n            var parts = [];\n            while (node.parent !== node) {\n                parts.push(node.name);\n                node = node.parent;\n            }\n            parts.push(node.mount.opts.root);\n            parts.reverse();\n            return PATH.join.apply(null, parts);\n        };\n\n        BFSEmscriptenFS.prototype.flagsToPermissionString = function (flags) {\n            if (flags in this.flagsToPermissionStringMap) {\n                return this.flagsToPermissionStringMap[flags];\n            } else {\n                return flags;\n            }\n        };\n        return BFSEmscriptenFS;\n    })();\n    exports.BFSEmscriptenFS = BFSEmscriptenFS;\n\n    // Make it available on the global BrowserFS object.\n    BrowserFS['EmscriptenFS'] = BFSEmscriptenFS;\n});\n//# sourceMappingURL=emscripten_fs.js.map\n;\n","define('core/browserfs',[\"require\", \"exports\", './buffer', './node_fs', './node_path', './node_process'], function(require, exports, buffer, node_fs, node_path, node_process) {\n    /**\n    * Installs BrowserFS onto the given object.\n    * We recommend that you run install with the 'window' object to make things\n    * global, as in Node.\n    *\n    * Properties installed:\n    *\n    * * Buffer\n    * * process\n    * * require (we monkey-patch it)\n    *\n    * This allows you to write code as if you were running inside Node.\n    * @param {object} obj - The object to install things onto (e.g. window)\n    */\n    function install(obj) {\n        obj.Buffer = buffer.Buffer;\n        obj.process = node_process.process;\n        var oldRequire = obj.require != null ? obj.require : null;\n\n        // Monkey-patch require for Node-style code.\n        obj.require = function (arg) {\n            var rv = exports.BFSRequire(arg);\n            if (rv == null) {\n                return oldRequire.apply(null, Array.prototype.slice.call(arguments, 0));\n            } else {\n                return rv;\n            }\n        };\n    }\n    exports.install = install;\n\n    exports.FileSystem = {};\n    function registerFileSystem(name, fs) {\n        exports.FileSystem[name] = fs;\n    }\n    exports.registerFileSystem = registerFileSystem;\n\n    function BFSRequire(module) {\n        switch (module) {\n            case 'fs':\n                return node_fs.fs;\n            case 'path':\n                return node_path.path;\n            case 'buffer':\n                // The 'buffer' module has 'Buffer' as a property.\n                return buffer;\n            case 'process':\n                return node_process.process;\n            default:\n                return exports.FileSystem[module];\n        }\n    }\n    exports.BFSRequire = BFSRequire;\n\n    /**\n    * You must call this function with a properly-instantiated root file system\n    * before using any file system API method.\n    * @param {BrowserFS.FileSystem} rootFS - The root filesystem to use for the\n    *   entire BrowserFS file system.\n    */\n    function initialize(rootfs) {\n        return node_fs.fs._initialize(rootfs);\n    }\n    exports.initialize = initialize;\n});\n//# sourceMappingURL=browserfs.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('core/file_system',[\"require\", \"exports\", './api_error', './file_flag', './node_path', './buffer'], function(require, exports, api_error, file_flag, node_path, buffer) {\n    var ApiError = api_error.ApiError;\n    var ErrorCode = api_error.ErrorCode;\n    var path = node_path.path;\n    var Buffer = buffer.Buffer;\n    var ActionType = file_flag.ActionType;\n\n    \n\n    \n\n    /**\n    * Basic filesystem class. Most filesystems should extend this class, as it\n    * provides default implementations for a handful of methods.\n    */\n    var BaseFileSystem = (function () {\n        function BaseFileSystem() {\n        }\n        BaseFileSystem.prototype.supportsLinks = function () {\n            return false;\n        };\n        BaseFileSystem.prototype.diskSpace = function (p, cb) {\n            cb(0, 0);\n        };\n\n        /**\n        * Opens the file at path p with the given flag. The file must exist.\n        * @param p The path to open.\n        * @param flag The flag to use when opening the file.\n        */\n        BaseFileSystem.prototype.openFile = function (p, flag, cb) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n\n        /**\n        * Create the file at path p with the given mode. Then, open it with the given\n        * flag.\n        */\n        BaseFileSystem.prototype.createFile = function (p, flag, mode, cb) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.open = function (p, flag, mode, cb) {\n            var _this = this;\n            var must_be_file = function (e, stats) {\n                if (e) {\n                    switch (flag.pathNotExistsAction()) {\n                        case 3 /* CREATE_FILE */:\n                            // Ensure parent exists.\n                            return _this.stat(path.dirname(p), false, function (e, parentStats) {\n                                if (e) {\n                                    cb(e);\n                                } else if (!parentStats.isDirectory()) {\n                                    cb(new ApiError(7 /* ENOTDIR */, path.dirname(p) + \" is not a directory.\"));\n                                } else {\n                                    _this.createFile(p, flag, mode, cb);\n                                }\n                            });\n                        case 1 /* THROW_EXCEPTION */:\n                            return cb(new ApiError(1 /* ENOENT */, \"\" + p + \" doesn't exist.\"));\n                        default:\n                            return cb(new ApiError(9 /* EINVAL */, 'Invalid FileFlag object.'));\n                    }\n                } else {\n                    // File exists.\n                    if (stats.isDirectory()) {\n                        return cb(new ApiError(8 /* EISDIR */, p + \" is a directory.\"));\n                    }\n                    switch (flag.pathExistsAction()) {\n                        case 1 /* THROW_EXCEPTION */:\n                            return cb(new ApiError(6 /* EEXIST */, p + \" already exists.\"));\n                        case 2 /* TRUNCATE_FILE */:\n                            // NOTE: In a previous implementation, we deleted the file and\n                            // re-created it. However, this created a race condition if another\n                            // asynchronous request was trying to read the file, as the file\n                            // would not exist for a small period of time.\n                            return _this.openFile(p, flag, function (e, fd) {\n                                if (e) {\n                                    cb(e);\n                                } else {\n                                    fd.truncate(0, function () {\n                                        fd.sync(function () {\n                                            cb(null, fd);\n                                        });\n                                    });\n                                }\n                            });\n                        case 0 /* NOP */:\n                            return _this.openFile(p, flag, cb);\n                        default:\n                            return cb(new ApiError(9 /* EINVAL */, 'Invalid FileFlag object.'));\n                    }\n                }\n            };\n            this.stat(p, false, must_be_file);\n        };\n        BaseFileSystem.prototype.rename = function (oldPath, newPath, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.renameSync = function (oldPath, newPath) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.stat = function (p, isLstat, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.statSync = function (p, isLstat) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n\n        /**\n        * Opens the file at path p with the given flag. The file must exist.\n        * @param p The path to open.\n        * @param flag The flag to use when opening the file.\n        * @return A File object corresponding to the opened file.\n        */\n        BaseFileSystem.prototype.openFileSync = function (p, flag) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n\n        /**\n        * Create the file at path p with the given mode. Then, open it with the given\n        * flag.\n        */\n        BaseFileSystem.prototype.createFileSync = function (p, flag, mode) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.openSync = function (p, flag, mode) {\n            // Check if the path exists, and is a file.\n            var stats;\n            try  {\n                stats = this.statSync(p, false);\n            } catch (e) {\n                switch (flag.pathNotExistsAction()) {\n                    case 3 /* CREATE_FILE */:\n                        // Ensure parent exists.\n                        var parentStats = this.statSync(path.dirname(p), false);\n                        if (!parentStats.isDirectory()) {\n                            throw new ApiError(7 /* ENOTDIR */, path.dirname(p) + \" is not a directory.\");\n                        }\n                        return this.createFileSync(p, flag, mode);\n                    case 1 /* THROW_EXCEPTION */:\n                        throw new ApiError(1 /* ENOENT */, \"\" + p + \" doesn't exist.\");\n                    default:\n                        throw new ApiError(9 /* EINVAL */, 'Invalid FileFlag object.');\n                }\n            }\n\n            // File exists.\n            if (stats.isDirectory()) {\n                throw new ApiError(8 /* EISDIR */, p + \" is a directory.\");\n            }\n            switch (flag.pathExistsAction()) {\n                case 1 /* THROW_EXCEPTION */:\n                    throw new ApiError(6 /* EEXIST */, p + \" already exists.\");\n                case 2 /* TRUNCATE_FILE */:\n                    // Delete file.\n                    this.unlinkSync(p);\n\n                    // Create file. Use the same mode as the old file.\n                    // Node itself modifies the ctime when this occurs, so this action\n                    // will preserve that behavior if the underlying file system\n                    // supports those properties.\n                    return this.createFileSync(p, flag, stats.mode);\n                case 0 /* NOP */:\n                    return this.openFileSync(p, flag);\n                default:\n                    throw new ApiError(9 /* EINVAL */, 'Invalid FileFlag object.');\n            }\n        };\n        BaseFileSystem.prototype.unlink = function (p, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.unlinkSync = function (p) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.rmdir = function (p, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.rmdirSync = function (p) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.mkdir = function (p, mode, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.mkdirSync = function (p, mode) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.readdir = function (p, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.readdirSync = function (p) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.exists = function (p, cb) {\n            this.stat(p, null, function (err) {\n                cb(err == null);\n            });\n        };\n        BaseFileSystem.prototype.existsSync = function (p) {\n            try  {\n                this.statSync(p, true);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        };\n        BaseFileSystem.prototype.realpath = function (p, cache, cb) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                var splitPath = p.split(path.sep);\n\n                for (var i = 0; i < splitPath.length; i++) {\n                    var addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(null, addPaths);\n                }\n            } else {\n                // No symlinks. We just need to verify that it exists.\n                this.exists(p, function (doesExist) {\n                    if (doesExist) {\n                        cb(null, p);\n                    } else {\n                        cb(new ApiError(1 /* ENOENT */, \"File \" + p + \" not found.\"));\n                    }\n                });\n            }\n        };\n        BaseFileSystem.prototype.realpathSync = function (p, cache) {\n            if (this.supportsLinks()) {\n                // The path could contain symlinks. Split up the path,\n                // resolve any symlinks, return the resolved string.\n                var splitPath = p.split(path.sep);\n\n                for (var i = 0; i < splitPath.length; i++) {\n                    var addPaths = splitPath.slice(0, i + 1);\n                    splitPath[i] = path.join.apply(null, addPaths);\n                }\n            } else {\n                // No symlinks. We just need to verify that it exists.\n                if (this.existsSync(p)) {\n                    return p;\n                } else {\n                    throw new ApiError(1 /* ENOENT */, \"File \" + p + \" not found.\");\n                }\n            }\n        };\n        BaseFileSystem.prototype.truncate = function (p, len, cb) {\n            this.open(p, file_flag.FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\n                if (er) {\n                    return cb(er);\n                }\n                fd.truncate(len, (function (er) {\n                    fd.close((function (er2) {\n                        cb(er || er2);\n                    }));\n                }));\n            }));\n        };\n        BaseFileSystem.prototype.truncateSync = function (p, len) {\n            var fd = this.openSync(p, file_flag.FileFlag.getFileFlag('r+'), 0x1a4);\n\n            try  {\n                fd.truncateSync(len);\n            } catch (e) {\n                throw e;\n            } finally {\n                fd.closeSync();\n            }\n        };\n        BaseFileSystem.prototype.readFile = function (fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            var oldCb = cb;\n\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (err == null) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                fd.stat(function (err, stat) {\n                    if (err != null) {\n                        return cb(err);\n                    }\n\n                    // Allocate buffer.\n                    var buf = new Buffer(stat.size);\n                    fd.read(buf, 0, stat.size, 0, function (err) {\n                        if (err != null) {\n                            return cb(err);\n                        } else if (encoding === null) {\n                            return cb(err, buf);\n                        }\n                        try  {\n                            cb(null, buf.toString(encoding));\n                        } catch (e) {\n                            cb(e);\n                        }\n                    });\n                });\n            });\n        };\n        BaseFileSystem.prototype.readFileSync = function (fname, encoding, flag) {\n            // Get file.\n            var fd = this.openSync(fname, flag, 0x1a4);\n            try  {\n                var stat = fd.statSync();\n\n                // Allocate buffer.\n                var buf = new Buffer(stat.size);\n                fd.readSync(buf, 0, stat.size, 0);\n                fd.closeSync();\n                if (encoding === null) {\n                    return buf;\n                }\n                return buf.toString(encoding);\n            } finally {\n                fd.closeSync();\n            }\n        };\n        BaseFileSystem.prototype.writeFile = function (fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            var oldCb = cb;\n\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err != null) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err != null ? err : err2);\n                    });\n                };\n\n                try  {\n                    if (typeof data === 'string') {\n                        data = new Buffer(data, encoding);\n                    }\n                } catch (e) {\n                    return cb(e);\n                }\n\n                // Write into file.\n                fd.write(data, 0, data.length, 0, cb);\n            });\n        };\n        BaseFileSystem.prototype.writeFileSync = function (fname, data, encoding, flag, mode) {\n            // Get file.\n            var fd = this.openSync(fname, flag, mode);\n            try  {\n                if (typeof data === 'string') {\n                    data = new Buffer(data, encoding);\n                }\n\n                // Write into file.\n                fd.writeSync(data, 0, data.length, 0);\n            } finally {\n                fd.closeSync();\n            }\n        };\n        BaseFileSystem.prototype.appendFile = function (fname, data, encoding, flag, mode, cb) {\n            // Wrap cb in file closing code.\n            var oldCb = cb;\n            this.open(fname, flag, mode, function (err, fd) {\n                if (err != null) {\n                    return cb(err);\n                }\n                cb = function (err) {\n                    fd.close(function (err2) {\n                        oldCb(err != null ? err : err2);\n                    });\n                };\n                if (typeof data === 'string') {\n                    data = new Buffer(data, encoding);\n                }\n                fd.write(data, 0, data.length, null, cb);\n            });\n        };\n        BaseFileSystem.prototype.appendFileSync = function (fname, data, encoding, flag, mode) {\n            var fd = this.openSync(fname, flag, mode);\n            try  {\n                if (typeof data === 'string') {\n                    data = new Buffer(data, encoding);\n                }\n                fd.writeSync(data, 0, data.length, null);\n            } finally {\n                fd.closeSync();\n            }\n        };\n        BaseFileSystem.prototype.chmod = function (p, isLchmod, mode, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.chmodSync = function (p, isLchmod, mode) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.chown = function (p, isLchown, uid, gid, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.chownSync = function (p, isLchown, uid, gid) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.utimes = function (p, atime, mtime, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.utimesSync = function (p, atime, mtime) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.link = function (srcpath, dstpath, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.linkSync = function (srcpath, dstpath) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.symlink = function (srcpath, dstpath, type, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.symlinkSync = function (srcpath, dstpath, type) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFileSystem.prototype.readlink = function (p, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFileSystem.prototype.readlinkSync = function (p) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        return BaseFileSystem;\n    })();\n    exports.BaseFileSystem = BaseFileSystem;\n\n    /**\n    * Implements the asynchronous API in terms of the synchronous API.\n    * @class SynchronousFileSystem\n    */\n    var SynchronousFileSystem = (function (_super) {\n        __extends(SynchronousFileSystem, _super);\n        function SynchronousFileSystem() {\n            _super.apply(this, arguments);\n        }\n        SynchronousFileSystem.prototype.supportsSynch = function () {\n            return true;\n        };\n\n        SynchronousFileSystem.prototype.rename = function (oldPath, newPath, cb) {\n            try  {\n                this.renameSync(oldPath, newPath);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.stat = function (p, isLstat, cb) {\n            try  {\n                cb(null, this.statSync(p, isLstat));\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.open = function (p, flags, mode, cb) {\n            try  {\n                cb(null, this.openSync(p, flags, mode));\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.unlink = function (p, cb) {\n            try  {\n                this.unlinkSync(p);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.rmdir = function (p, cb) {\n            try  {\n                this.rmdirSync(p);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.mkdir = function (p, mode, cb) {\n            try  {\n                this.mkdirSync(p, mode);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.readdir = function (p, cb) {\n            try  {\n                cb(null, this.readdirSync(p));\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.chmod = function (p, isLchmod, mode, cb) {\n            try  {\n                this.chmodSync(p, isLchmod, mode);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.chown = function (p, isLchown, uid, gid, cb) {\n            try  {\n                this.chownSync(p, isLchown, uid, gid);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.utimes = function (p, atime, mtime, cb) {\n            try  {\n                this.utimesSync(p, atime, mtime);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.link = function (srcpath, dstpath, cb) {\n            try  {\n                this.linkSync(srcpath, dstpath);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.symlink = function (srcpath, dstpath, type, cb) {\n            try  {\n                this.symlinkSync(srcpath, dstpath, type);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        SynchronousFileSystem.prototype.readlink = function (p, cb) {\n            try  {\n                cb(null, this.readlinkSync(p));\n            } catch (e) {\n                cb(e);\n            }\n        };\n        return SynchronousFileSystem;\n    })(BaseFileSystem);\n    exports.SynchronousFileSystem = SynchronousFileSystem;\n});\n//# sourceMappingURL=file_system.js.map\n;\n","define('generic/inode',[\"require\", \"exports\", '../core/node_fs_stats', '../core/buffer'], function(require, exports, node_fs_stats, buffer) {\n    /**\n    * Generic inode definition that can easily be serialized.\n    */\n    var Inode = (function () {\n        function Inode(id, size, mode, atime, mtime, ctime) {\n            this.id = id;\n            this.size = size;\n            this.mode = mode;\n            this.atime = atime;\n            this.mtime = mtime;\n            this.ctime = ctime;\n        }\n        /**\n        * Handy function that converts the Inode to a Node Stats object.\n        */\n        Inode.prototype.toStats = function () {\n            return new node_fs_stats.Stats((this.mode & 0xF000) === 16384 /* DIRECTORY */ ? 16384 /* DIRECTORY */ : 32768 /* FILE */, this.size, this.mode, new Date(this.atime), new Date(this.mtime), new Date(this.ctime));\n        };\n\n        /**\n        * Get the size of this Inode, in bytes.\n        */\n        Inode.prototype.getSize = function () {\n            // ASSUMPTION: ID is ASCII (1 byte per char).\n            return 30 + this.id.length;\n        };\n\n        /**\n        * Writes the inode into the start of the buffer.\n        */\n        Inode.prototype.toBuffer = function (buff) {\n            if (typeof buff === \"undefined\") { buff = new buffer.Buffer(this.getSize()); }\n            buff.writeUInt32LE(this.size, 0);\n            buff.writeUInt16LE(this.mode, 4);\n            buff.writeDoubleLE(this.atime, 6);\n            buff.writeDoubleLE(this.mtime, 14);\n            buff.writeDoubleLE(this.ctime, 22);\n            buff.write(this.id, 30, this.id.length, 'ascii');\n            return buff;\n        };\n\n        /**\n        * Updates the Inode using information from the stats object. Used by file\n        * systems at sync time, e.g.:\n        * - Program opens file and gets a File object.\n        * - Program mutates file. File object is responsible for maintaining\n        *   metadata changes locally -- typically in a Stats object.\n        * - Program closes file. File object's metadata changes are synced with the\n        *   file system.\n        * @return True if any changes have occurred.\n        */\n        Inode.prototype.update = function (stats) {\n            var hasChanged = false;\n            if (this.size !== stats.size) {\n                this.size = stats.size;\n                hasChanged = true;\n            }\n\n            if (this.mode !== stats.mode) {\n                this.mode = stats.mode;\n                hasChanged = true;\n            }\n\n            var atimeMs = stats.atime.getTime();\n            if (this.atime !== atimeMs) {\n                this.atime = atimeMs;\n                hasChanged = true;\n            }\n\n            var mtimeMs = stats.mtime.getTime();\n            if (this.mtime !== mtimeMs) {\n                this.mtime = mtimeMs;\n                hasChanged = true;\n            }\n\n            var ctimeMs = stats.ctime.getTime();\n            if (this.ctime !== ctimeMs) {\n                this.ctime = ctimeMs;\n                hasChanged = true;\n            }\n\n            return hasChanged;\n        };\n\n        /**\n        * Converts the buffer into an Inode.\n        */\n        Inode.fromBuffer = function (buffer) {\n            if (buffer === undefined) {\n                throw new Error(\"NO\");\n            }\n            return new Inode(buffer.toString('ascii', 30), buffer.readUInt32LE(0), buffer.readUInt16LE(4), buffer.readDoubleLE(6), buffer.readDoubleLE(14), buffer.readDoubleLE(22));\n        };\n\n        // XXX: Copied from Stats. Should reconcile these two into something more\n        //      compact.\n        /**\n        * @return [Boolean] True if this item is a file.\n        */\n        Inode.prototype.isFile = function () {\n            return (this.mode & 0xF000) === 32768 /* FILE */;\n        };\n\n        /**\n        * @return [Boolean] True if this item is a directory.\n        */\n        Inode.prototype.isDirectory = function () {\n            return (this.mode & 0xF000) === 16384 /* DIRECTORY */;\n        };\n        return Inode;\n    })();\n\n    \n    return Inode;\n});\n//# sourceMappingURL=inode.js.map\n;\n","define('core/node_fs_stats',[\"require\", \"exports\"], function(require, exports) {\n    /**\n    * Indicates the type of the given file. Applied to 'mode'.\n    */\n    (function (FileType) {\n        FileType[FileType[\"FILE\"] = 0x8000] = \"FILE\";\n        FileType[FileType[\"DIRECTORY\"] = 0x4000] = \"DIRECTORY\";\n        FileType[FileType[\"SYMLINK\"] = 0xA000] = \"SYMLINK\";\n    })(exports.FileType || (exports.FileType = {}));\n    var FileType = exports.FileType;\n\n    /**\n    * Emulation of Node's `fs.Stats` object.\n    *\n    * Attribute descriptions are from `man 2 stat'\n    * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\n    * @see http://man7.org/linux/man-pages/man2/stat.2.html\n    * @class\n    */\n    var Stats = (function () {\n        /**\n        * Provides information about a particular entry in the file system.\n        * @param [Number] item_type type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\n        * @param [Number] size Size of the item in bytes. For directories/symlinks,\n        *   this is normally the size of the struct that represents the item.\n        * @param [Number] mode Unix-style file mode (e.g. 0o644)\n        * @param [Date?] atime time of last access\n        * @param [Date?] mtime time of last modification\n        * @param [Date?] ctime time of creation\n        */\n        function Stats(item_type, size, mode, atime, mtime, ctime) {\n            if (typeof atime === \"undefined\") { atime = new Date(); }\n            if (typeof mtime === \"undefined\") { mtime = new Date(); }\n            if (typeof ctime === \"undefined\") { ctime = new Date(); }\n            this.size = size;\n            this.mode = mode;\n            this.atime = atime;\n            this.mtime = mtime;\n            this.ctime = ctime;\n            /**\n            * UNSUPPORTED ATTRIBUTES\n            * I assume no one is going to need these details, although we could fake\n            * appropriate values if need be.\n            */\n            // ID of device containing file\n            this.dev = 0;\n            // inode number\n            this.ino = 0;\n            // device ID (if special file)\n            this.rdev = 0;\n            // number of hard links\n            this.nlink = 1;\n            // blocksize for file system I/O\n            this.blksize = 4096;\n            // @todo Maybe support these? atm, it's a one-user filesystem.\n            // user ID of owner\n            this.uid = 0;\n            // group ID of owner\n            this.gid = 0;\n            if (this.mode == null) {\n                switch (item_type) {\n                    case 32768 /* FILE */:\n                        this.mode = 0x1a4;\n                        break;\n                    case 16384 /* DIRECTORY */:\n                    default:\n                        this.mode = 0x1ff;\n                }\n            }\n\n            // number of 512B blocks allocated\n            this.blocks = Math.ceil(size / 512);\n\n            // Check if mode also includes top-most bits, which indicate the file's\n            // type.\n            if (this.mode < 0x1000) {\n                this.mode |= item_type;\n            }\n        }\n        /**\n        * **Nonstandard**: Clone the stats object.\n        * @return [BrowserFS.node.fs.Stats]\n        */\n        Stats.prototype.clone = function () {\n            return new Stats(this.mode & 0xF000, this.size, this.mode & 0xFFF, this.atime, this.mtime, this.ctime);\n        };\n\n        /**\n        * @return [Boolean] True if this item is a file.\n        */\n        Stats.prototype.isFile = function () {\n            return (this.mode & 0xF000) === 32768 /* FILE */;\n        };\n\n        /**\n        * @return [Boolean] True if this item is a directory.\n        */\n        Stats.prototype.isDirectory = function () {\n            return (this.mode & 0xF000) === 16384 /* DIRECTORY */;\n        };\n\n        /**\n        * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\n        */\n        Stats.prototype.isSymbolicLink = function () {\n            return (this.mode & 0xF000) === 40960 /* SYMLINK */;\n        };\n\n        /**\n        * Change the mode of the file. We use this helper function to prevent messing\n        * up the type of the file, which is encoded in mode.\n        */\n        Stats.prototype.chmod = function (mode) {\n            this.mode = (this.mode & 0xF000) | mode;\n        };\n\n        // We don't support the following types of files.\n        Stats.prototype.isSocket = function () {\n            return false;\n        };\n\n        Stats.prototype.isBlockDevice = function () {\n            return false;\n        };\n\n        Stats.prototype.isCharacterDevice = function () {\n            return false;\n        };\n\n        Stats.prototype.isFIFO = function () {\n            return false;\n        };\n        return Stats;\n    })();\n    exports.Stats = Stats;\n});\n//# sourceMappingURL=node_fs_stats.js.map\n;\n","define('core/file',[\"require\", \"exports\", './api_error'], function(require, exports, api_error) {\n    var ApiError = api_error.ApiError;\n    var ErrorCode = api_error.ErrorCode;\n\n    /**\n    * Base class that contains shared implementations of functions for the file\n    * object.\n    * @class\n    */\n    var BaseFile = (function () {\n        function BaseFile() {\n        }\n        BaseFile.prototype.sync = function (cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFile.prototype.syncSync = function () {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFile.prototype.datasync = function (cb) {\n            this.sync(cb);\n        };\n        BaseFile.prototype.datasyncSync = function () {\n            return this.syncSync();\n        };\n        BaseFile.prototype.chown = function (uid, gid, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFile.prototype.chownSync = function (uid, gid) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFile.prototype.chmod = function (mode, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFile.prototype.chmodSync = function (mode) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        BaseFile.prototype.utimes = function (atime, mtime, cb) {\n            cb(new ApiError(14 /* ENOTSUP */));\n        };\n        BaseFile.prototype.utimesSync = function (atime, mtime) {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n        return BaseFile;\n    })();\n    exports.BaseFile = BaseFile;\n});\n//# sourceMappingURL=file.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('generic/preload_file',[\"require\", \"exports\", '../core/file', '../core/buffer', '../core/api_error', '../core/node_fs'], function(require, exports, file, buffer, api_error, node_fs) {\n    var ApiError = api_error.ApiError;\n    var ErrorCode = api_error.ErrorCode;\n    var fs = node_fs.fs;\n    var Buffer = buffer.Buffer;\n\n    /**\n    * An implementation of the File interface that operates on a file that is\n    * completely in-memory. PreloadFiles are backed by a Buffer.\n    *\n    * This is also an abstract class, as it lacks an implementation of 'sync' and\n    * 'close'. Each filesystem that wishes to use this file representation must\n    * extend this class and implement those two methods.\n    * @todo 'close' lever that disables functionality once closed.\n    */\n    var PreloadFile = (function (_super) {\n        __extends(PreloadFile, _super);\n        /**\n        * Creates a file with the given path and, optionally, the given contents. Note\n        * that, if contents is specified, it will be mutated by the file!\n        * @param [BrowserFS.FileSystem] _fs The file system that created the file.\n        * @param [String] _path\n        * @param [BrowserFS.FileMode] _mode The mode that the file was opened using.\n        *   Dictates permissions and where the file pointer starts.\n        * @param [BrowserFS.node.fs.Stats] _stat The stats object for the given file.\n        *   PreloadFile will mutate this object. Note that this object must contain\n        *   the appropriate mode that the file was opened as.\n        * @param [BrowserFS.node.Buffer?] contents A buffer containing the entire\n        *   contents of the file. PreloadFile will mutate this buffer. If not\n        *   specified, we assume it is a new file.\n        */\n        function PreloadFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this);\n            this._pos = 0;\n            this._fs = _fs;\n            this._path = _path;\n            this._flag = _flag;\n            this._stat = _stat;\n            if (contents != null) {\n                this._buffer = contents;\n            } else {\n                // Empty buffer. It'll expand once we write stuff to it.\n                this._buffer = new Buffer(0);\n            }\n\n            // Note: This invariant is *not* maintained once the file starts getting\n            // modified.\n            if (this._stat.size !== this._buffer.length) {\n                throw new Error(\"Invalid buffer: Buffer is \" + this._buffer.length + \" long, yet Stats object specifies that file is \" + this._stat.size + \" long.\");\n            }\n        }\n        /**\n        * Get the path to this file.\n        * @return [String] The path to the file.\n        */\n        PreloadFile.prototype.getPath = function () {\n            return this._path;\n        };\n\n        /**\n        * Get the current file position.\n        *\n        * We emulate the following bug mentioned in the Node documentation:\n        * > On Linux, positional writes don't work when the file is opened in append\n        *   mode. The kernel ignores the position argument and always appends the data\n        *   to the end of the file.\n        * @return [Number] The current file position.\n        */\n        PreloadFile.prototype.getPos = function () {\n            if (this._flag.isAppendable()) {\n                return this._stat.size;\n            }\n            return this._pos;\n        };\n\n        /**\n        * Advance the current file position by the indicated number of positions.\n        * @param [Number] delta\n        */\n        PreloadFile.prototype.advancePos = function (delta) {\n            return this._pos += delta;\n        };\n\n        /**\n        * Set the file position.\n        * @param [Number] newPos\n        */\n        PreloadFile.prototype.setPos = function (newPos) {\n            return this._pos = newPos;\n        };\n\n        /**\n        * **Core**: Asynchronous sync. Must be implemented by subclasses of this\n        * class.\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        PreloadFile.prototype.sync = function (cb) {\n            try  {\n                this.syncSync();\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * **Core**: Synchronous sync.\n        */\n        PreloadFile.prototype.syncSync = function () {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n\n        /**\n        * **Core**: Asynchronous close. Must be implemented by subclasses of this\n        * class.\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        PreloadFile.prototype.close = function (cb) {\n            try  {\n                this.closeSync();\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * **Core**: Synchronous close.\n        */\n        PreloadFile.prototype.closeSync = function () {\n            throw new ApiError(14 /* ENOTSUP */);\n        };\n\n        /**\n        * Asynchronous `stat`.\n        * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb\n        */\n        PreloadFile.prototype.stat = function (cb) {\n            try  {\n                cb(null, this._stat.clone());\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * Synchronous `stat`.\n        */\n        PreloadFile.prototype.statSync = function () {\n            return this._stat.clone();\n        };\n\n        /**\n        * Asynchronous truncate.\n        * @param [Number] len\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        PreloadFile.prototype.truncate = function (len, cb) {\n            try  {\n                this.truncateSync(len);\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\n                    this.sync(cb);\n                }\n                cb();\n            } catch (e) {\n                return cb(e);\n            }\n        };\n\n        /**\n        * Synchronous truncate.\n        * @param [Number] len\n        */\n        PreloadFile.prototype.truncateSync = function (len) {\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(0 /* EPERM */, 'File not opened with a writeable mode.');\n            }\n            this._stat.mtime = new Date();\n            if (len > this._buffer.length) {\n                var buf = new Buffer(len - this._buffer.length);\n                buf.fill(0);\n\n                // Write will set @_stat.size for us.\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                    this.syncSync();\n                }\n                return;\n            }\n            this._stat.size = len;\n\n            // Truncate buffer to 'len'.\n            var newBuff = new Buffer(len);\n            this._buffer.copy(newBuff, 0, 0, len);\n            this._buffer = newBuff;\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\n                this.syncSync();\n            }\n        };\n\n        /**\n        * Write buffer to the file.\n        * Note that it is unsafe to use fs.write multiple times on the same file\n        * without waiting for the callback.\n        * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n        *  the file.\n        * @param [Number] offset Offset in the buffer to start reading data from.\n        * @param [Number] length The amount of bytes to write to the file.\n        * @param [Number] position Offset from the beginning of the file where this\n        *   data should be written. If position is null, the data will be written at\n        *   the current position.\n        * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]\n        *   cb The number specifies the number of bytes written into the file.\n        */\n        PreloadFile.prototype.write = function (buffer, offset, length, position, cb) {\n            try  {\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * Write buffer to the file.\n        * Note that it is unsafe to use fs.writeSync multiple times on the same file\n        * without waiting for the callback.\n        * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n        *  the file.\n        * @param [Number] offset Offset in the buffer to start reading data from.\n        * @param [Number] length The amount of bytes to write to the file.\n        * @param [Number] position Offset from the beginning of the file where this\n        *   data should be written. If position is null, the data will be written at\n        *   the current position.\n        * @return [Number]\n        */\n        PreloadFile.prototype.writeSync = function (buffer, offset, length, position) {\n            if (position == null) {\n                position = this.getPos();\n            }\n            if (!this._flag.isWriteable()) {\n                throw new ApiError(0 /* EPERM */, 'File not opened with a writeable mode.');\n            }\n            var endFp = position + length;\n            if (endFp > this._stat.size) {\n                this._stat.size = endFp;\n                if (endFp > this._buffer.length) {\n                    // Extend the buffer!\n                    var newBuff = new Buffer(endFp);\n                    this._buffer.copy(newBuff);\n                    this._buffer = newBuff;\n                }\n            }\n            var len = buffer.copy(this._buffer, position, offset, offset + length);\n            this._stat.mtime = new Date();\n            if (this._flag.isSynchronous()) {\n                this.syncSync();\n                return len;\n            }\n            this.setPos(position + len);\n            return len;\n        };\n\n        /**\n        * Read data from the file.\n        * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n        *   written to.\n        * @param [Number] offset The offset within the buffer where writing will\n        *   start.\n        * @param [Number] length An integer specifying the number of bytes to read.\n        * @param [Number] position An integer specifying where to begin reading from\n        *   in the file. If position is null, data will be read from the current file\n        *   position.\n        * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The\n        *   number is the number of bytes read\n        */\n        PreloadFile.prototype.read = function (buffer, offset, length, position, cb) {\n            try  {\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * Read data from the file.\n        * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n        *   written to.\n        * @param [Number] offset The offset within the buffer where writing will\n        *   start.\n        * @param [Number] length An integer specifying the number of bytes to read.\n        * @param [Number] position An integer specifying where to begin reading from\n        *   in the file. If position is null, data will be read from the current file\n        *   position.\n        * @return [Number]\n        */\n        PreloadFile.prototype.readSync = function (buffer, offset, length, position) {\n            if (!this._flag.isReadable()) {\n                throw new ApiError(0 /* EPERM */, 'File not opened with a readable mode.');\n            }\n            if (position == null) {\n                position = this.getPos();\n            }\n            var endRead = position + length;\n            if (endRead > this._stat.size) {\n                length = this._stat.size - position;\n            }\n            var rv = this._buffer.copy(buffer, offset, position, position + length);\n            this._stat.atime = new Date();\n            this._pos = position + length;\n            return rv;\n        };\n\n        /**\n        * Asynchronous `fchmod`.\n        * @param [Number|String] mode\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        PreloadFile.prototype.chmod = function (mode, cb) {\n            try  {\n                this.chmodSync(mode);\n                cb();\n            } catch (e) {\n                cb(e);\n            }\n        };\n\n        /**\n        * Asynchronous `fchmod`.\n        * @param [Number] mode\n        */\n        PreloadFile.prototype.chmodSync = function (mode) {\n            if (!this._fs.supportsProps()) {\n                throw new ApiError(14 /* ENOTSUP */);\n            }\n            this._stat.chmod(mode);\n            this.syncSync();\n        };\n        return PreloadFile;\n    })(file.BaseFile);\n    exports.PreloadFile = PreloadFile;\n\n    /**\n    * File class for the InMemory and XHR file systems.\n    * Doesn't sync to anything, so it works nicely for memory-only files.\n    */\n    var NoSyncFile = (function (_super) {\n        __extends(NoSyncFile, _super);\n        function NoSyncFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this, _fs, _path, _flag, _stat, contents);\n        }\n        /**\n        * Asynchronous sync. Doesn't do anything, simply calls the cb.\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        NoSyncFile.prototype.sync = function (cb) {\n            cb();\n        };\n\n        /**\n        * Synchronous sync. Doesn't do anything.\n        */\n        NoSyncFile.prototype.syncSync = function () {\n        };\n\n        /**\n        * Asynchronous close. Doesn't do anything, simply calls the cb.\n        * @param [Function(BrowserFS.ApiError)] cb\n        */\n        NoSyncFile.prototype.close = function (cb) {\n            cb();\n        };\n\n        /**\n        * Synchronous close. Doesn't do anything.\n        */\n        NoSyncFile.prototype.closeSync = function () {\n        };\n        return NoSyncFile;\n    })(PreloadFile);\n    exports.NoSyncFile = NoSyncFile;\n});\n//# sourceMappingURL=preload_file.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('generic/key_value_filesystem',[\"require\", \"exports\", '../core/file_system', '../core/api_error', '../core/node_fs_stats', '../core/node_path', '../generic/inode', '../core/buffer', '../generic/preload_file'], function(require, exports, file_system, api_error, node_fs_stats, node_path, Inode, buffer, preload_file) {\n    var ROOT_NODE_ID = \"/\", path = node_path.path, ApiError = api_error.ApiError, Buffer = buffer.Buffer;\n\n    /**\n    * Generates a random ID.\n    */\n    function GenerateRandomID() {\n        // From http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    }\n\n    /**\n    * Helper function. Checks if 'e' is defined. If so, it triggers the callback\n    * with 'e' and returns false. Otherwise, returns true.\n    */\n    function noError(e, cb) {\n        if (e) {\n            cb(e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n    * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\n    * triggers the callback with 'e', and returns false. Otherwise, returns true.\n    */\n    function noErrorTx(e, tx, cb) {\n        if (e) {\n            tx.abort(function () {\n                cb(e);\n            });\n            return false;\n        }\n        return true;\n    }\n\n    \n\n    \n\n    \n\n    \n\n    /**\n    * A simple RW transaction for simple synchronous key-value stores.\n    */\n    var SimpleSyncRWTransaction = (function () {\n        function SimpleSyncRWTransaction(store) {\n            this.store = store;\n            /**\n            * Stores data in the keys we modify prior to modifying them.\n            * Allows us to roll back commits.\n            */\n            this.originalData = {};\n            /**\n            * List of keys modified in this transaction, if any.\n            */\n            this.modifiedKeys = [];\n        }\n        /**\n        * Stashes given key value pair into `originalData` if it doesn't already\n        * exist. Allows us to stash values the program is requesting anyway to\n        * prevent needless `get` requests if the program modifies the data later\n        * on during the transaction.\n        */\n        SimpleSyncRWTransaction.prototype.stashOldValue = function (key, value) {\n            // Keep only the earliest value in the transaction.\n            if (!this.originalData.hasOwnProperty(key)) {\n                this.originalData[key] = value;\n            }\n        };\n\n        /**\n        * Marks the given key as modified, and stashes its value if it has not been\n        * stashed already.\n        */\n        SimpleSyncRWTransaction.prototype.markModified = function (key) {\n            if (this.modifiedKeys.indexOf(key) === -1) {\n                this.modifiedKeys.push(key);\n                if (!this.originalData.hasOwnProperty(key)) {\n                    this.originalData[key] = this.store.get(key);\n                }\n            }\n        };\n\n        SimpleSyncRWTransaction.prototype.get = function (key) {\n            var val = this.store.get(key);\n            this.stashOldValue(key, val);\n            return val;\n        };\n\n        SimpleSyncRWTransaction.prototype.put = function (key, data, overwrite) {\n            this.markModified(key);\n            return this.store.put(key, data, overwrite);\n        };\n\n        SimpleSyncRWTransaction.prototype.delete = function (key) {\n            this.markModified(key);\n            this.store.delete(key);\n        };\n\n        SimpleSyncRWTransaction.prototype.commit = function () {\n        };\n        SimpleSyncRWTransaction.prototype.abort = function () {\n            // Rollback old values.\n            var i, key, value;\n            for (i = 0; i < this.modifiedKeys.length; i++) {\n                key = this.modifiedKeys[i];\n                value = this.originalData[key];\n                if (value === null) {\n                    // Key didn't exist.\n                    this.store.delete(key);\n                } else {\n                    // Key existed. Store old value.\n                    this.store.put(key, value, true);\n                }\n            }\n        };\n        return SimpleSyncRWTransaction;\n    })();\n    exports.SimpleSyncRWTransaction = SimpleSyncRWTransaction;\n\n    var SyncKeyValueFile = (function (_super) {\n        __extends(SyncKeyValueFile, _super);\n        function SyncKeyValueFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this, _fs, _path, _flag, _stat, contents);\n        }\n        SyncKeyValueFile.prototype.syncSync = function () {\n            this._fs._syncSync(this._path, this._buffer, this._stat);\n        };\n\n        SyncKeyValueFile.prototype.closeSync = function () {\n            this.syncSync();\n        };\n        return SyncKeyValueFile;\n    })(preload_file.PreloadFile);\n    exports.SyncKeyValueFile = SyncKeyValueFile;\n\n    /**\n    * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\n    * underlying key-value store.\n    *\n    * We use a unique ID for each node in the file system. The root node has a\n    * fixed ID.\n    * @todo Introduce Node ID caching.\n    * @todo Check modes.\n    */\n    var SyncKeyValueFileSystem = (function (_super) {\n        __extends(SyncKeyValueFileSystem, _super);\n        function SyncKeyValueFileSystem(options) {\n            _super.call(this);\n            this.store = options.store;\n\n            // INVARIANT: Ensure that the root exists.\n            this.makeRootDirectory();\n        }\n        SyncKeyValueFileSystem.isAvailable = function () {\n            return true;\n        };\n        SyncKeyValueFileSystem.prototype.getName = function () {\n            return this.store.name();\n        };\n        SyncKeyValueFileSystem.prototype.isReadOnly = function () {\n            return false;\n        };\n        SyncKeyValueFileSystem.prototype.supportsSymlinks = function () {\n            return false;\n        };\n        SyncKeyValueFileSystem.prototype.supportsProps = function () {\n            return false;\n        };\n        SyncKeyValueFileSystem.prototype.supportsSynch = function () {\n            return true;\n        };\n\n        /**\n        * Checks if the root directory exists. Creates it if it doesn't.\n        */\n        SyncKeyValueFileSystem.prototype.makeRootDirectory = function () {\n            var tx = this.store.beginTransaction('readwrite');\n            if (tx.get(ROOT_NODE_ID) === undefined) {\n                // Create new inode.\n                var currTime = (new Date()).getTime(), dirInode = new Inode(GenerateRandomID(), 4096, 511 | 16384 /* DIRECTORY */, currTime, currTime, currTime);\n\n                // If the root doesn't exist, the first random ID shouldn't exist,\n                // either.\n                tx.put(dirInode.id, new Buffer(\"{}\"), false);\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\n                tx.commit();\n            }\n        };\n\n        /**\n        * Helper function for findINode.\n        * @param parent The parent directory of the file we are attempting to find.\n        * @param filename The filename of the inode we are attempting to find, minus\n        *   the parent.\n        * @return string The ID of the file's inode in the file system.\n        */\n        SyncKeyValueFileSystem.prototype._findINode = function (tx, parent, filename) {\n            var _this = this;\n            var read_directory = function (inode) {\n                // Get the root's directory listing.\n                var dirList = _this.getDirListing(tx, parent, inode);\n\n                // Get the file's ID.\n                if (dirList[filename]) {\n                    return dirList[filename];\n                } else {\n                    throw ApiError.ENOENT(path.resolve(parent, filename));\n                }\n            };\n            if (parent === '/') {\n                if (filename === '') {\n                    // BASE CASE #1: Return the root's ID.\n                    return ROOT_NODE_ID;\n                } else {\n                    // BASE CASE #2: Find the item in the root ndoe.\n                    return read_directory(this.getINode(tx, parent, ROOT_NODE_ID));\n                }\n            } else {\n                return read_directory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));\n            }\n        };\n\n        /**\n        * Finds the Inode of the given path.\n        * @param p The path to look up.\n        * @return The Inode of the path p.\n        * @todo memoize/cache\n        */\n        SyncKeyValueFileSystem.prototype.findINode = function (tx, p) {\n            return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));\n        };\n\n        /**\n        * Given the ID of a node, retrieves the corresponding Inode.\n        * @param tx The transaction to use.\n        * @param p The corresponding path to the file (used for error messages).\n        * @param id The ID to look up.\n        */\n        SyncKeyValueFileSystem.prototype.getINode = function (tx, p, id) {\n            var inode = tx.get(id);\n            if (inode === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return Inode.fromBuffer(inode);\n        };\n\n        /**\n        * Given the Inode of a directory, retrieves the corresponding directory\n        * listing.\n        */\n        SyncKeyValueFileSystem.prototype.getDirListing = function (tx, p, inode) {\n            if (!inode.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n            var data = tx.get(inode.id);\n            if (data === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return JSON.parse(data.toString());\n        };\n\n        /**\n        * Creates a new node under a random ID. Retries 5 times before giving up in\n        * the exceedingly unlikely chance that we try to reuse a random GUID.\n        * @return The GUID that the data was stored under.\n        */\n        SyncKeyValueFileSystem.prototype.addNewNode = function (tx, data) {\n            var retries = 0, currId;\n            while (retries < 5) {\n                try  {\n                    currId = GenerateRandomID();\n                    tx.put(currId, data, false);\n                    return currId;\n                } catch (e) {\n                    // Ignore and reroll.\n                }\n            }\n            throw new ApiError(2 /* EIO */, 'Unable to commit data to key-value store.');\n        };\n\n        /**\n        * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n        * the given mode.\n        * Note: This will commit the transaction.\n        * @param p The path to the new file.\n        * @param type The type of the new file.\n        * @param mode The mode to create the new file with.\n        * @param data The data to store at the file's data node.\n        * @return The Inode for the new file.\n        */\n        SyncKeyValueFileSystem.prototype.commitNewFile = function (tx, p, type, mode, data) {\n            var parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\n\n            // Invariant: The root always exists.\n            // If we don't check this prior to taking steps below, we will create a\n            // file with name '' in root should p == '/'.\n            if (p === '/') {\n                throw ApiError.EEXIST(p);\n            }\n\n            // Check if file already exists.\n            if (dirListing[fname]) {\n                throw ApiError.EEXIST(p);\n            }\n\n            try  {\n                // Commit data.\n                var dataId = this.addNewNode(tx, data), fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime), fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\n\n                // Update and commit parent directory listing.\n                dirListing[fname] = fileNodeId;\n                tx.put(parentNode.id, new Buffer(JSON.stringify(dirListing)), true);\n            } catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n            return fileNode;\n        };\n\n        /**\n        * Delete all contents stored in the file system.\n        */\n        SyncKeyValueFileSystem.prototype.empty = function () {\n            this.store.clear();\n\n            // INVARIANT: Root always exists.\n            this.makeRootDirectory();\n        };\n\n        SyncKeyValueFileSystem.prototype.renameSync = function (oldPath, newPath) {\n            var tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\n            if (!oldDirList[oldName]) {\n                throw ApiError.ENOENT(oldPath);\n            }\n            var nodeId = oldDirList[oldName];\n            delete oldDirList[oldName];\n\n            // Invariant: Can't move a folder inside itself.\n            // This funny little hack ensures that the check passes only if oldPath\n            // is a subpath of newParent. We append '/' to avoid matching folders that\n            // are a substring of the bottom-most folder in the path.\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n                throw new ApiError(5 /* EBUSY */, oldParent);\n            }\n\n            // Add newPath to parent's directory listing.\n            var newDirNode, newDirList;\n            if (newParent === oldParent) {\n                // Prevent us from re-grabbing the same directory listing, which still\n                // contains oldName.\n                newDirNode = oldDirNode;\n                newDirList = oldDirList;\n            } else {\n                newDirNode = this.findINode(tx, newParent);\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\n            }\n\n            if (newDirList[newName]) {\n                // If it's a file, delete it.\n                var newNameNode = this.getINode(tx, newPath, newDirList[newName]);\n                if (newNameNode.isFile()) {\n                    try  {\n                        tx.delete(newNameNode.id);\n                        tx.delete(newDirList[newName]);\n                    } catch (e) {\n                        tx.abort();\n                        throw e;\n                    }\n                } else {\n                    throw ApiError.EPERM(newPath);\n                }\n            }\n            newDirList[newName] = nodeId;\n\n            try  {\n                tx.put(oldDirNode.id, new Buffer(JSON.stringify(oldDirList)), true);\n                tx.put(newDirNode.id, new Buffer(JSON.stringify(newDirList)), true);\n            } catch (e) {\n                tx.abort();\n                throw e;\n            }\n\n            tx.commit();\n        };\n\n        SyncKeyValueFileSystem.prototype.statSync = function (p, isLstat) {\n            // Get the inode to the item, convert it into a Stats object.\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\n        };\n\n        SyncKeyValueFileSystem.prototype.createFileSync = function (p, flag, mode) {\n            var tx = this.store.beginTransaction('readwrite'), data = new Buffer(0), newFile = this.commitNewFile(tx, p, 32768 /* FILE */, mode, data);\n\n            // Open the file.\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\n        };\n\n        SyncKeyValueFileSystem.prototype.openFileSync = function (p, flag) {\n            var tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\n            if (data === undefined) {\n                throw ApiError.ENOENT(p);\n            }\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\n        };\n\n        /**\n        * Remove all traces of the given path from the file system.\n        * @param p The path to remove from the file system.\n        * @param isDir Does the path belong to a directory, or a file?\n        * @todo Update mtime.\n        */\n        SyncKeyValueFileSystem.prototype.removeEntry = function (p, isDir) {\n            var tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);\n\n            if (!parentListing[fileName]) {\n                throw ApiError.ENOENT(p);\n            }\n\n            // Remove from directory listing of parent.\n            var fileNodeId = parentListing[fileName];\n            delete parentListing[fileName];\n\n            // Get file inode.\n            var fileNode = this.getINode(tx, p, fileNodeId);\n            if (!isDir && fileNode.isDirectory()) {\n                throw ApiError.EISDIR(p);\n            } else if (isDir && !fileNode.isDirectory()) {\n                throw ApiError.ENOTDIR(p);\n            }\n\n            try  {\n                // Delete data.\n                tx.delete(fileNode.id);\n\n                // Delete node.\n                tx.delete(fileNodeId);\n\n                // Update directory listing.\n                tx.put(parentNode.id, new Buffer(JSON.stringify(parentListing)), true);\n            } catch (e) {\n                tx.abort();\n                throw e;\n            }\n\n            // Success.\n            tx.commit();\n        };\n\n        SyncKeyValueFileSystem.prototype.unlinkSync = function (p) {\n            this.removeEntry(p, false);\n        };\n\n        SyncKeyValueFileSystem.prototype.rmdirSync = function (p) {\n            this.removeEntry(p, true);\n        };\n\n        SyncKeyValueFileSystem.prototype.mkdirSync = function (p, mode) {\n            var tx = this.store.beginTransaction('readwrite'), data = new Buffer('{}');\n            this.commitNewFile(tx, p, 16384 /* DIRECTORY */, mode, data);\n        };\n\n        SyncKeyValueFileSystem.prototype.readdirSync = function (p) {\n            var tx = this.store.beginTransaction('readonly');\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\n        };\n\n        SyncKeyValueFileSystem.prototype._syncSync = function (p, data, stats) {\n            // @todo Ensure mtime updates properly, and use that to determine if a data\n            //       update is required.\n            var tx = this.store.beginTransaction('readwrite'), fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\n\n            try  {\n                // Sync data.\n                tx.put(fileInode.id, data, true);\n\n                // Sync metadata.\n                if (inodeChanged) {\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\n                }\n            } catch (e) {\n                tx.abort();\n                throw e;\n            }\n            tx.commit();\n        };\n        return SyncKeyValueFileSystem;\n    })(file_system.SynchronousFileSystem);\n    exports.SyncKeyValueFileSystem = SyncKeyValueFileSystem;\n\n    \n\n    \n\n    \n\n    var AsyncKeyValueFile = (function (_super) {\n        __extends(AsyncKeyValueFile, _super);\n        function AsyncKeyValueFile(_fs, _path, _flag, _stat, contents) {\n            _super.call(this, _fs, _path, _flag, _stat, contents);\n        }\n        AsyncKeyValueFile.prototype.sync = function (cb) {\n            this._fs._sync(this._path, this._buffer, this._stat, cb);\n        };\n\n        AsyncKeyValueFile.prototype.close = function (cb) {\n            this.sync(cb);\n        };\n        return AsyncKeyValueFile;\n    })(preload_file.PreloadFile);\n    exports.AsyncKeyValueFile = AsyncKeyValueFile;\n\n    /**\n    * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\n    * an underlying asynchronous key-value store.\n    */\n    var AsyncKeyValueFileSystem = (function (_super) {\n        __extends(AsyncKeyValueFileSystem, _super);\n        function AsyncKeyValueFileSystem() {\n            _super.apply(this, arguments);\n        }\n        /**\n        * Initializes the file system. Typically called by subclasses' async\n        * constructors.\n        */\n        AsyncKeyValueFileSystem.prototype.init = function (store, cb) {\n            this.store = store;\n\n            // INVARIANT: Ensure that the root exists.\n            this.makeRootDirectory(cb);\n        };\n\n        AsyncKeyValueFileSystem.isAvailable = function () {\n            return true;\n        };\n        AsyncKeyValueFileSystem.prototype.getName = function () {\n            return this.store.name();\n        };\n        AsyncKeyValueFileSystem.prototype.isReadOnly = function () {\n            return false;\n        };\n        AsyncKeyValueFileSystem.prototype.supportsSymlinks = function () {\n            return false;\n        };\n        AsyncKeyValueFileSystem.prototype.supportsProps = function () {\n            return false;\n        };\n        AsyncKeyValueFileSystem.prototype.supportsSynch = function () {\n            return false;\n        };\n\n        /**\n        * Checks if the root directory exists. Creates it if it doesn't.\n        */\n        AsyncKeyValueFileSystem.prototype.makeRootDirectory = function (cb) {\n            var tx = this.store.beginTransaction('readwrite');\n            tx.get(ROOT_NODE_ID, function (e, data) {\n                if (e || data === undefined) {\n                    // Create new inode.\n                    var currTime = (new Date()).getTime(), dirInode = new Inode(GenerateRandomID(), 4096, 511 | 16384 /* DIRECTORY */, currTime, currTime, currTime);\n\n                    // If the root doesn't exist, the first random ID shouldn't exist,\n                    // either.\n                    tx.put(dirInode.id, new Buffer(\"{}\"), false, function (e) {\n                        if (noErrorTx(e, tx, cb)) {\n                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, function (e) {\n                                if (e) {\n                                    tx.abort(function () {\n                                        cb(e);\n                                    });\n                                } else {\n                                    tx.commit(cb);\n                                }\n                            });\n                        }\n                    });\n                } else {\n                    // We're good.\n                    tx.commit(cb);\n                }\n            });\n        };\n\n        /**\n        * Helper function for findINode.\n        * @param parent The parent directory of the file we are attempting to find.\n        * @param filename The filename of the inode we are attempting to find, minus\n        *   the parent.\n        * @param cb Passed an error or the ID of the file's inode in the file system.\n        */\n        AsyncKeyValueFileSystem.prototype._findINode = function (tx, parent, filename, cb) {\n            var _this = this;\n            var handle_directory_listings = function (e, inode, dirList) {\n                if (e) {\n                    cb(e);\n                } else if (dirList[filename]) {\n                    cb(null, dirList[filename]);\n                } else {\n                    cb(ApiError.ENOENT(path.resolve(parent, filename)));\n                }\n            };\n\n            if (parent === '/') {\n                if (filename === '') {\n                    // BASE CASE #1: Return the root's ID.\n                    cb(null, ROOT_NODE_ID);\n                } else {\n                    // BASE CASE #2: Find the item in the root node.\n                    this.getINode(tx, parent, ROOT_NODE_ID, function (e, inode) {\n                        if (noError(e, cb)) {\n                            _this.getDirListing(tx, parent, inode, function (e, dirList) {\n                                // handle_directory_listings will handle e for us.\n                                handle_directory_listings(e, inode, dirList);\n                            });\n                        }\n                    });\n                }\n            } else {\n                // Get the parent directory's INode, and find the file in its directory\n                // listing.\n                this.findINodeAndDirListing(tx, parent, handle_directory_listings);\n            }\n        };\n\n        /**\n        * Finds the Inode of the given path.\n        * @param p The path to look up.\n        * @param cb Passed an error or the Inode of the path p.\n        * @todo memoize/cache\n        */\n        AsyncKeyValueFileSystem.prototype.findINode = function (tx, p, cb) {\n            var _this = this;\n            this._findINode(tx, path.dirname(p), path.basename(p), function (e, id) {\n                if (noError(e, cb)) {\n                    _this.getINode(tx, p, id, cb);\n                }\n            });\n        };\n\n        /**\n        * Given the ID of a node, retrieves the corresponding Inode.\n        * @param tx The transaction to use.\n        * @param p The corresponding path to the file (used for error messages).\n        * @param id The ID to look up.\n        * @param cb Passed an error or the inode under the given id.\n        */\n        AsyncKeyValueFileSystem.prototype.getINode = function (tx, p, id, cb) {\n            tx.get(id, function (e, data) {\n                if (noError(e, cb)) {\n                    if (data === undefined) {\n                        cb(ApiError.ENOENT(p));\n                    } else {\n                        cb(null, Inode.fromBuffer(data));\n                    }\n                }\n            });\n        };\n\n        /**\n        * Given the Inode of a directory, retrieves the corresponding directory\n        * listing.\n        */\n        AsyncKeyValueFileSystem.prototype.getDirListing = function (tx, p, inode, cb) {\n            if (!inode.isDirectory()) {\n                cb(ApiError.ENOTDIR(p));\n            } else {\n                tx.get(inode.id, function (e, data) {\n                    if (noError(e, cb)) {\n                        try  {\n                            cb(null, JSON.parse(data.toString()));\n                        } catch (e) {\n                            // Occurs when data is undefined, or corresponds to something other\n                            // than a directory listing. The latter should never occur unless\n                            // the file system is corrupted.\n                            cb(ApiError.ENOENT(p));\n                        }\n                    }\n                });\n            }\n        };\n\n        /**\n        * Given a path to a directory, retrieves the corresponding INode and\n        * directory listing.\n        */\n        AsyncKeyValueFileSystem.prototype.findINodeAndDirListing = function (tx, p, cb) {\n            var _this = this;\n            this.findINode(tx, p, function (e, inode) {\n                if (noError(e, cb)) {\n                    _this.getDirListing(tx, p, inode, function (e, listing) {\n                        if (noError(e, cb)) {\n                            cb(null, inode, listing);\n                        }\n                    });\n                }\n            });\n        };\n\n        /**\n        * Adds a new node under a random ID. Retries 5 times before giving up in\n        * the exceedingly unlikely chance that we try to reuse a random GUID.\n        * @param cb Passed an error or the GUID that the data was stored under.\n        */\n        AsyncKeyValueFileSystem.prototype.addNewNode = function (tx, data, cb) {\n            var retries = 0, currId, reroll = function () {\n                if (++retries === 5) {\n                    // Max retries hit. Return with an error.\n                    cb(new ApiError(2 /* EIO */, 'Unable to commit data to key-value store.'));\n                } else {\n                    // Try again.\n                    currId = GenerateRandomID();\n                    tx.put(currId, data, false, function (e, committed) {\n                        if (e || !committed) {\n                            reroll();\n                        } else {\n                            // Successfully stored under 'currId'.\n                            cb(null, currId);\n                        }\n                    });\n                }\n            };\n            reroll();\n        };\n\n        /**\n        * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\n        * the given mode.\n        * Note: This will commit the transaction.\n        * @param p The path to the new file.\n        * @param type The type of the new file.\n        * @param mode The mode to create the new file with.\n        * @param data The data to store at the file's data node.\n        * @param cb Passed an error or the Inode for the new file.\n        */\n        AsyncKeyValueFileSystem.prototype.commitNewFile = function (tx, p, type, mode, data, cb) {\n            var _this = this;\n            var parentDir = path.dirname(p), fname = path.basename(p), currTime = (new Date()).getTime();\n\n            // Invariant: The root always exists.\n            // If we don't check this prior to taking steps below, we will create a\n            // file with name '' in root should p == '/'.\n            if (p === '/') {\n                return cb(ApiError.EEXIST(p));\n            }\n\n            // Let's build a pyramid of code!\n            // Step 1: Get the parent directory's inode and directory listing\n            this.findINodeAndDirListing(tx, parentDir, function (e, parentNode, dirListing) {\n                if (noErrorTx(e, tx, cb)) {\n                    if (dirListing[fname]) {\n                        // File already exists.\n                        tx.abort(function () {\n                            cb(ApiError.EEXIST(p));\n                        });\n                    } else {\n                        // Step 2: Commit data to store.\n                        _this.addNewNode(tx, data, function (e, dataId) {\n                            if (noErrorTx(e, tx, cb)) {\n                                // Step 3: Commit the file's inode to the store.\n                                var fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\n                                _this.addNewNode(tx, fileInode.toBuffer(), function (e, fileInodeId) {\n                                    if (noErrorTx(e, tx, cb)) {\n                                        // Step 4: Update parent directory's listing.\n                                        dirListing[fname] = fileInodeId;\n                                        tx.put(parentNode.id, new Buffer(JSON.stringify(dirListing)), true, function (e) {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                // Step 5: Commit and return the new inode.\n                                                tx.commit(function (e) {\n                                                    if (noErrorTx(e, tx, cb)) {\n                                                        cb(null, fileInode);\n                                                    }\n                                                });\n                                            }\n                                        });\n                                    }\n                                });\n                            }\n                        });\n                    }\n                }\n            });\n        };\n\n        /**\n        * Delete all contents stored in the file system.\n        */\n        AsyncKeyValueFileSystem.prototype.empty = function (cb) {\n            var _this = this;\n            this.store.clear(function (e) {\n                if (noError(e, cb)) {\n                    // INVARIANT: Root always exists.\n                    _this.makeRootDirectory(cb);\n                }\n            });\n        };\n\n        AsyncKeyValueFileSystem.prototype.rename = function (oldPath, newPath, cb) {\n            var _this = this;\n            var tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), inodes = {}, lists = {}, errorOccurred = false;\n\n            // Invariant: Can't move a folder inside itself.\n            // This funny little hack ensures that the check passes only if oldPath\n            // is a subpath of newParent. We append '/' to avoid matching folders that\n            // are a substring of the bottom-most folder in the path.\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\n                return cb(new ApiError(5 /* EBUSY */, oldParent));\n            }\n\n            /**\n            * Responsible for Phase 2 of the rename operation: Modifying and\n            * committing the directory listings. Called once we have successfully\n            * retrieved both the old and new parent's inodes and listings.\n            */\n            var theOleSwitcharoo = function () {\n                // Sanity check: Ensure both paths are present, and no error has occurred.\n                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\n                    return;\n                }\n                var oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\n\n                // Delete file from old parent.\n                if (!oldParentList[oldName]) {\n                    cb(ApiError.ENOENT(oldPath));\n                } else {\n                    var fileId = oldParentList[oldName];\n                    delete oldParentList[oldName];\n\n                    // Finishes off the renaming process by adding the file to the new\n                    // parent.\n                    var completeRename = function () {\n                        newParentList[newName] = fileId;\n\n                        // Commit old parent's list.\n                        tx.put(oldParentINode.id, new Buffer(JSON.stringify(oldParentList)), true, function (e) {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (oldParent === newParent) {\n                                    // DONE!\n                                    tx.commit(cb);\n                                } else {\n                                    // Commit new parent's list.\n                                    tx.put(newParentINode.id, new Buffer(JSON.stringify(newParentList)), true, function (e) {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.commit(cb);\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    };\n\n                    if (newParentList[newName]) {\n                        // 'newPath' already exists. Check if it's a file or a directory, and\n                        // act accordingly.\n                        _this.getINode(tx, newPath, newParentList[newName], function (e, inode) {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (inode.isFile()) {\n                                    // Delete the file and continue.\n                                    tx.delete(inode.id, function (e) {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            tx.delete(newParentList[newName], function (e) {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    completeRename();\n                                                }\n                                            });\n                                        }\n                                    });\n                                } else {\n                                    // Can't overwrite a directory using rename.\n                                    tx.abort(function (e) {\n                                        cb(ApiError.EPERM(newPath));\n                                    });\n                                }\n                            }\n                        });\n                    } else {\n                        completeRename();\n                    }\n                }\n            };\n\n            /**\n            * Grabs a path's inode and directory listing, and shoves it into the\n            * inodes and lists hashes.\n            */\n            var processInodeAndListings = function (p) {\n                _this.findINodeAndDirListing(tx, p, function (e, node, dirList) {\n                    if (e) {\n                        if (!errorOccurred) {\n                            errorOccurred = true;\n                            tx.abort(function () {\n                                cb(e);\n                            });\n                        }\n                        // If error has occurred already, just stop here.\n                    } else {\n                        inodes[p] = node;\n                        lists[p] = dirList;\n                        theOleSwitcharoo();\n                    }\n                });\n            };\n\n            processInodeAndListings(oldParent);\n            if (oldParent !== newParent) {\n                processInodeAndListings(newParent);\n            }\n        };\n\n        AsyncKeyValueFileSystem.prototype.stat = function (p, isLstat, cb) {\n            var tx = this.store.beginTransaction('readonly');\n            this.findINode(tx, p, function (e, inode) {\n                if (noError(e, cb)) {\n                    cb(null, inode.toStats());\n                }\n            });\n        };\n\n        AsyncKeyValueFileSystem.prototype.createFile = function (p, flag, mode, cb) {\n            var _this = this;\n            var tx = this.store.beginTransaction('readwrite'), data = new Buffer(0);\n\n            this.commitNewFile(tx, p, 32768 /* FILE */, mode, data, function (e, newFile) {\n                if (noError(e, cb)) {\n                    cb(null, new AsyncKeyValueFile(_this, p, flag, newFile.toStats(), data));\n                }\n            });\n        };\n\n        AsyncKeyValueFileSystem.prototype.openFile = function (p, flag, cb) {\n            var _this = this;\n            var tx = this.store.beginTransaction('readonly');\n\n            // Step 1: Grab the file's inode.\n            this.findINode(tx, p, function (e, inode) {\n                if (noError(e, cb)) {\n                    // Step 2: Grab the file's data.\n                    tx.get(inode.id, function (e, data) {\n                        if (noError(e, cb)) {\n                            if (data === undefined) {\n                                cb(ApiError.ENOENT(p));\n                            } else {\n                                cb(null, new AsyncKeyValueFile(_this, p, flag, inode.toStats(), data));\n                            }\n                        }\n                    });\n                }\n            });\n        };\n\n        /**\n        * Remove all traces of the given path from the file system.\n        * @param p The path to remove from the file system.\n        * @param isDir Does the path belong to a directory, or a file?\n        * @todo Update mtime.\n        */\n        AsyncKeyValueFileSystem.prototype.removeEntry = function (p, isDir, cb) {\n            var _this = this;\n            var tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), fileName = path.basename(p);\n\n            // Step 1: Get parent directory's node and directory listing.\n            this.findINodeAndDirListing(tx, parent, function (e, parentNode, parentListing) {\n                if (noErrorTx(e, tx, cb)) {\n                    if (!parentListing[fileName]) {\n                        tx.abort(function () {\n                            cb(ApiError.ENOENT(p));\n                        });\n                    } else {\n                        // Remove from directory listing of parent.\n                        var fileNodeId = parentListing[fileName];\n                        delete parentListing[fileName];\n\n                        // Step 2: Get file inode.\n                        _this.getINode(tx, p, fileNodeId, function (e, fileNode) {\n                            if (noErrorTx(e, tx, cb)) {\n                                if (!isDir && fileNode.isDirectory()) {\n                                    tx.abort(function () {\n                                        cb(ApiError.EISDIR(p));\n                                    });\n                                } else if (isDir && !fileNode.isDirectory()) {\n                                    tx.abort(function () {\n                                        cb(ApiError.ENOTDIR(p));\n                                    });\n                                } else {\n                                    // Step 3: Delete data.\n                                    tx.delete(fileNode.id, function (e) {\n                                        if (noErrorTx(e, tx, cb)) {\n                                            // Step 4: Delete node.\n                                            tx.delete(fileNodeId, function (e) {\n                                                if (noErrorTx(e, tx, cb)) {\n                                                    // Step 5: Update directory listing.\n                                                    tx.put(parentNode.id, new Buffer(JSON.stringify(parentListing)), true, function (e) {\n                                                        if (noErrorTx(e, tx, cb)) {\n                                                            tx.commit(cb);\n                                                        }\n                                                    });\n                                                }\n                                            });\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                }\n            });\n        };\n\n        AsyncKeyValueFileSystem.prototype.unlink = function (p, cb) {\n            this.removeEntry(p, false, cb);\n        };\n\n        AsyncKeyValueFileSystem.prototype.rmdir = function (p, cb) {\n            this.removeEntry(p, true, cb);\n        };\n\n        AsyncKeyValueFileSystem.prototype.mkdir = function (p, mode, cb) {\n            var tx = this.store.beginTransaction('readwrite'), data = new Buffer('{}');\n            this.commitNewFile(tx, p, 16384 /* DIRECTORY */, mode, data, cb);\n        };\n\n        AsyncKeyValueFileSystem.prototype.readdir = function (p, cb) {\n            var _this = this;\n            var tx = this.store.beginTransaction('readonly');\n            this.findINode(tx, p, function (e, inode) {\n                if (noError(e, cb)) {\n                    _this.getDirListing(tx, p, inode, function (e, dirListing) {\n                        if (noError(e, cb)) {\n                            cb(null, Object.keys(dirListing));\n                        }\n                    });\n                }\n            });\n        };\n\n        AsyncKeyValueFileSystem.prototype._sync = function (p, data, stats, cb) {\n            var _this = this;\n            // @todo Ensure mtime updates properly, and use that to determine if a data\n            //       update is required.\n            var tx = this.store.beginTransaction('readwrite');\n\n            // Step 1: Get the file node's ID.\n            this._findINode(tx, path.dirname(p), path.basename(p), function (e, fileInodeId) {\n                if (noErrorTx(e, tx, cb)) {\n                    // Step 2: Get the file inode.\n                    _this.getINode(tx, p, fileInodeId, function (e, fileInode) {\n                        if (noErrorTx(e, tx, cb)) {\n                            var inodeChanged = fileInode.update(stats);\n\n                            // Step 3: Sync the data.\n                            tx.put(fileInode.id, data, true, function (e) {\n                                if (noErrorTx(e, tx, cb)) {\n                                    // Step 4: Sync the metadata (if it changed)!\n                                    if (inodeChanged) {\n                                        tx.put(fileInodeId, fileInode.toBuffer(), true, function (e) {\n                                            if (noErrorTx(e, tx, cb)) {\n                                                tx.commit(cb);\n                                            }\n                                        });\n                                    } else {\n                                        // No need to sync metadata; return.\n                                        tx.commit(cb);\n                                    }\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        };\n        return AsyncKeyValueFileSystem;\n    })(file_system.BaseFileSystem);\n    exports.AsyncKeyValueFileSystem = AsyncKeyValueFileSystem;\n});\n//# sourceMappingURL=key_value_filesystem.js.map\n;\n","define('core/global',[\"require\", \"exports\"], function(require, exports) {\n    /**\n    * Exports the global scope variable.\n    * In the main browser thread, this is \"window\".\n    * In a WebWorker, this is \"self\".\n    * In Node, this is \"global\".\n    */\n    var toExport;\n    if (typeof (window) !== 'undefined') {\n        toExport = window;\n    } else if (typeof (self) !== 'undefined') {\n        toExport = self;\n    } else {\n        toExport = global;\n    }\n    \n    return toExport;\n});\n//# sourceMappingURL=global.js.map\n;\n","var __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\ndefine('backend/IndexedDB',[\"require\", \"exports\", '../core/buffer', '../core/browserfs', '../generic/key_value_filesystem', '../core/api_error', '../core/buffer_core_arraybuffer', '../core/global'], function(require, exports, buffer, browserfs, kvfs, api_error, buffer_core_arraybuffer, global) {\n    var Buffer = buffer.Buffer, ApiError = api_error.ApiError, ErrorCode = api_error.ErrorCode, indexedDB = global.indexedDB || global.mozIndexedDB || global.webkitIndexedDB || global.msIndexedDB;\n\n    /**\n    * Converts a DOMException or a DOMError from an IndexedDB event into a\n    * standardized BrowserFS API error.\n    */\n    function convertError(e, message) {\n        if (typeof message === \"undefined\") { message = e.toString(); }\n        switch (e.name) {\n            case \"NotFoundError\":\n                return new ApiError(1 /* ENOENT */, message);\n            case \"QuotaExceededError\":\n                return new ApiError(11 /* ENOSPC */, message);\n            default:\n                // The rest do not seem to map cleanly to standard error codes.\n                return new ApiError(2 /* EIO */, message);\n        }\n    }\n\n    /**\n    * Produces a new onerror handler for IDB. Our errors are always fatal, so we\n    * handle them generically: Call the user-supplied callback with a translated\n    * version of the error, and let the error bubble up.\n    */\n    function onErrorHandler(cb, code, message) {\n        if (typeof code === \"undefined\") { code = 2 /* EIO */; }\n        if (typeof message === \"undefined\") { message = null; }\n        return function (e) {\n            // Prevent the error from canceling the transaction.\n            e.preventDefault();\n            cb(new ApiError(code, message));\n        };\n    }\n\n    /**\n    * Converts a NodeBuffer into an ArrayBuffer.\n    */\n    function buffer2arraybuffer(data) {\n        // XXX: Typing hack.\n        var backing_mem = data.getBufferCore();\n        if (!(backing_mem instanceof buffer_core_arraybuffer.BufferCoreArrayBuffer)) {\n            // Copy into an ArrayBuffer-backed Buffer.\n            buffer = new Buffer(this._buffer.length);\n            this._buffer.copy(buffer);\n            backing_mem = buffer.getBufferCore();\n        }\n\n        // Reach into the BC, grab the DV.\n        var dv = backing_mem.getDataView();\n        return dv.buffer;\n    }\n\n    var IndexedDBROTransaction = (function () {\n        function IndexedDBROTransaction(tx, store) {\n            this.tx = tx;\n            this.store = store;\n        }\n        IndexedDBROTransaction.prototype.get = function (key, cb) {\n            try  {\n                var r = this.store.get(key);\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = function (event) {\n                    // IDB returns the value 'undefined' when you try to get keys that\n                    // don't exist. The caller expects this behavior.\n                    var result = event.target.result;\n                    if (result === undefined) {\n                        cb(null, result);\n                    } else {\n                        // IDB data is stored as an ArrayBuffer\n                        cb(null, new Buffer(result));\n                    }\n                };\n            } catch (e) {\n                cb(convertError(e));\n            }\n        };\n        return IndexedDBROTransaction;\n    })();\n    exports.IndexedDBROTransaction = IndexedDBROTransaction;\n\n    var IndexedDBRWTransaction = (function (_super) {\n        __extends(IndexedDBRWTransaction, _super);\n        function IndexedDBRWTransaction(tx, store) {\n            _super.call(this, tx, store);\n        }\n        IndexedDBRWTransaction.prototype.put = function (key, data, overwrite, cb) {\n            try  {\n                var arraybuffer = buffer2arraybuffer(data), r;\n                if (overwrite) {\n                    r = this.store.put(arraybuffer, key);\n                } else {\n                    // 'add' will never overwrite an existing key.\n                    r = this.store.add(arraybuffer, key);\n                }\n\n                // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = function (event) {\n                    cb(null, true);\n                };\n            } catch (e) {\n                cb(convertError(e));\n            }\n        };\n\n        IndexedDBRWTransaction.prototype.delete = function (key, cb) {\n            try  {\n                var r = this.store.delete(key);\n                r.onerror = onErrorHandler(cb);\n                r.onsuccess = function (event) {\n                    cb();\n                };\n            } catch (e) {\n                cb(convertError(e));\n            }\n        };\n\n        IndexedDBRWTransaction.prototype.commit = function (cb) {\n            // Return to the event loop to commit the transaction.\n            setTimeout(cb, 0);\n        };\n\n        IndexedDBRWTransaction.prototype.abort = function (cb) {\n            var _e;\n            try  {\n                this.tx.abort();\n            } catch (e) {\n                _e = convertError(e);\n            } finally {\n                cb(_e);\n            }\n        };\n        return IndexedDBRWTransaction;\n    })(IndexedDBROTransaction);\n    exports.IndexedDBRWTransaction = IndexedDBRWTransaction;\n\n    var IndexedDBStore = (function () {\n        /**\n        * Constructs an IndexedDB file system.\n        * @param cb Called once the database is instantiated and ready for use.\n        *   Passes an error if there was an issue instantiating the database.\n        * @param objectStoreName The name of this file system. You can have\n        *   multiple IndexedDB file systems operating at once, but each must have\n        *   a different name.\n        */\n        function IndexedDBStore(cb, storeName) {\n            if (typeof storeName === \"undefined\") { storeName = 'browserfs'; }\n            var _this = this;\n            this.storeName = storeName;\n            var openReq = indexedDB.open(this.storeName, 1);\n\n            openReq.onupgradeneeded = function (event) {\n                var db = event.target.result;\n\n                // Huh. This should never happen; we're at version 1. Why does another\n                // database exist?\n                if (db.objectStoreNames.contains(_this.storeName)) {\n                    db.deleteObjectStore(_this.storeName);\n                }\n                db.createObjectStore(_this.storeName);\n            };\n\n            openReq.onsuccess = function (event) {\n                _this.db = event.target.result;\n                cb(null, _this);\n            };\n\n            openReq.onerror = onErrorHandler(cb, 4 /* EACCES */);\n        }\n        IndexedDBStore.prototype.name = function () {\n            return \"IndexedDB - \" + this.storeName;\n        };\n\n        IndexedDBStore.prototype.clear = function (cb) {\n            try  {\n                var tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\n                r.onsuccess = function (event) {\n                    // Use setTimeout to commit transaction.\n                    setTimeout(cb, 0);\n                };\n                r.onerror = onErrorHandler(cb);\n            } catch (e) {\n                cb(convertError(e));\n            }\n        };\n\n        IndexedDBStore.prototype.beginTransaction = function (type) {\n            if (typeof type === \"undefined\") { type = 'readonly'; }\n            var tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\n            if (type === 'readwrite') {\n                return new IndexedDBRWTransaction(tx, objectStore);\n            } else if (type === 'readonly') {\n                return new IndexedDBROTransaction(tx, objectStore);\n            } else {\n                throw new ApiError(9 /* EINVAL */, 'Invalid transaction type.');\n            }\n        };\n        return IndexedDBStore;\n    })();\n    exports.IndexedDBStore = IndexedDBStore;\n\n    /**\n    * A file system that uses the IndexedDB key value file system.\n    */\n    var IndexedDBFileSystem = (function (_super) {\n        __extends(IndexedDBFileSystem, _super);\n        function IndexedDBFileSystem(cb, storeName) {\n            var _this = this;\n            _super.call(this);\n            new IndexedDBStore(function (e, store) {\n                if (e) {\n                    cb(e);\n                } else {\n                    _this.init(store, function (e) {\n                        cb(e, _this);\n                    });\n                }\n            }, storeName);\n        }\n        IndexedDBFileSystem.isAvailable = function () {\n            return typeof indexedDB !== 'undefined';\n        };\n        return IndexedDBFileSystem;\n    })(kvfs.AsyncKeyValueFileSystem);\n    exports.IndexedDBFileSystem = IndexedDBFileSystem;\n\n    browserfs.registerFileSystem('IndexedDB', IndexedDBFileSystem);\n});\n//# sourceMappingURL=IndexedDB.js.map\n;\n"]}